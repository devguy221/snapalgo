"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseSnapExecutor = void 0;
const providers_1 = require("@metamask/providers");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const openrpc_json_1 = __importDefault(require("../openrpc.json"));
const openrpc_guard_1 = require("../__GENERATED__/openrpc.guard");
const rpcMethods_1 = require("./rpcMethods");
const sortParams_1 = require("./sortParams");
const endowments_1 = require("./endowments");
const globalObject_1 = require("./globalObject");
const fallbackError = {
    code: eth_rpc_errors_1.errorCodes.rpc.internal,
    message: 'Execution Environment Error',
};
class BaseSnapExecutor {
    constructor(commandStream, rpcStream) {
        this.snapRpcHandlers = new Map();
        this.commandStream = commandStream;
        this.commandStream.on('data', this.onCommandRequest.bind(this));
        this.rpcStream = rpcStream;
        this.methods = (0, rpcMethods_1.rpcMethods)(this.startSnap.bind(this), (target, origin, request) => {
            const handler = this.snapRpcHandlers.get(target);
            if (!handler) {
                throw new Error(`No RPC handler registered for snap "${target}`);
            }
            return handler(origin, request);
        }, this.onTerminate.bind(this));
    }
    errorHandler(error, data = {}) {
        const serializedError = (0, eth_rpc_errors_1.serializeError)(error, {
            fallbackError,
            shouldIncludeStack: true,
        });
        this.notify({
            error: Object.assign(Object.assign({}, serializedError), { data: Object.assign(Object.assign({}, data), { stack: serializedError.stack }) }),
        });
    }
    async onCommandRequest(message) {
        if (!(0, openrpc_guard_1.isJsonRpcRequest)(message)) {
            throw new Error('Command stream received a non Json Rpc Request');
        }
        const { id, method, params } = message;
        if (id === undefined) {
            throw new Error('Notifications not supported');
        }
        if (method === 'rpc.discover') {
            this.respond(id, {
                result: openrpc_json_1.default,
            });
            return;
        }
        const methodObject = openrpc_json_1.default.methods.find((m) => m.name === method);
        if (!methodObject || !this.methods[method]) {
            this.respond(id, {
                error: eth_rpc_errors_1.ethErrors.rpc
                    .methodNotFound({
                    data: {
                        method,
                    },
                })
                    .serialize(),
            });
            return;
        }
        // support params by-name and by-position
        const paramsAsArray = (0, sortParams_1.sortParamKeys)(methodObject, params);
        try {
            const result = await this.methods[method](...paramsAsArray);
            this.respond(id, { result });
        }
        catch (e) {
            this.respond(id, {
                error: (0, eth_rpc_errors_1.serializeError)(e, {
                    fallbackError,
                }),
            });
        }
    }
    notify(requestObject) {
        this.commandStream.write(Object.assign(Object.assign({}, requestObject), { jsonrpc: '2.0' }));
    }
    respond(id, responseObj) {
        this.commandStream.write(Object.assign(Object.assign({}, responseObj), { id, jsonrpc: '2.0' }));
    }
    /**
     * Attempts to evaluate a snap in SES.
     * Generates the APIs for the snap. May throw on error.
     *
     * @param {string} snapName - The name of the snap.
     * @param {Array<string>} approvedPermissions - The snap's approved permissions.
     * Should always be a value returned from the permissions controller.
     * @param {string} sourceCode - The source code of the snap, in IIFE format.
     * @param {Array} endowments - An array of the names of the endowments.
     */
    startSnap(snapName, sourceCode, _endowments) {
        console.log(`starting snap '${snapName}' in worker`);
        if (this.snapPromiseErrorHandler) {
            globalObject_1.rootRealmGlobal.removeEventListener('unhandledrejection', this.snapPromiseErrorHandler);
        }
        if (this.snapErrorHandler) {
            globalObject_1.rootRealmGlobal.removeEventListener('error', this.snapErrorHandler);
        }
        this.snapErrorHandler = (error) => {
            this.errorHandler(error.error, { snapName });
        };
        this.snapPromiseErrorHandler = (error) => {
            this.errorHandler(error.reason, { snapName });
        };
        const wallet = this.createSnapProvider(snapName);
        try {
            const { endowments, teardown: endowmentTeardown } = (0, endowments_1.createEndowments)(wallet, _endowments);
            this.endowmentTeardown = endowmentTeardown;
            const compartment = new Compartment(Object.assign(Object.assign({}, endowments), { window: Object.assign({}, endowments), self: Object.assign({}, endowments) }));
            compartment.evaluate(sourceCode);
            globalObject_1.rootRealmGlobal.addEventListener('unhandledrejection', this.snapPromiseErrorHandler);
            globalObject_1.rootRealmGlobal.addEventListener('error', this.snapErrorHandler);
        }
        catch (err) {
            this.removeSnap(snapName);
            throw new Error(`Error while running snap '${snapName}': ${err.message}`);
        }
    }
    onTerminate() {
        if (this.endowmentTeardown) {
            this.endowmentTeardown();
        }
    }
    /**
     * Sets up the given snap's RPC message handler, creates a hardened
     * snap provider object (i.e. globalThis.wallet), and returns it.
     */
    createSnapProvider(snapName) {
        const snapProvider = new providers_1.MetaMaskInpageProvider(this.rpcStream, {
            shouldSendMetadata: false,
        });
        snapProvider.registerRpcMessageHandler = (func) => {
            console.log('Worker: Registering RPC message handler', func);
            if (this.snapRpcHandlers.has(snapName)) {
                throw new Error('RPC handler already registered.');
            }
            this.snapRpcHandlers.set(snapName, func);
        };
        // TODO: harden throws an error. Why?
        // return harden(snapProvider as SnapProvider);
        return snapProvider;
    }
    /**
     * Removes the snap with the given name. Specifically:
     * - Deletes the snap's RPC handler, if any
     */
    removeSnap(snapName) {
        this.snapRpcHandlers.delete(snapName);
    }
}
exports.BaseSnapExecutor = BaseSnapExecutor;
//# sourceMappingURL=BaseSnapExecutor.js.map