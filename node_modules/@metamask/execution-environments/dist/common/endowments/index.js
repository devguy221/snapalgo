"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEndowments = void 0;
const globalObject_1 = require("../globalObject");
const buffer_1 = __importDefault(require("./buffer"));
const timeout_1 = __importDefault(require("./timeout"));
const interval_1 = __importDefault(require("./interval"));
const wasm_1 = __importDefault(require("./wasm"));
/**
 * A map of endowment names to their factory functions. Some endowments share
 * the same factory function, but we only call each factory once for each snap.
 * See {@link createEndowments} for details.
 */
const endowmentFactories = [buffer_1.default, timeout_1.default, interval_1.default, wasm_1.default].reduce((factories, builder) => {
    builder.names.forEach((name) => {
        factories.set(name, builder.factory);
    });
    return factories;
}, new Map());
/**
 * Gets the endowments for a particular Snap. Some endowments, like `setTimeout`
 * and `clearTimeout`, must be attenuated so that they can only affect behavior
 * within the Snap's own realm. Therefore, we use factory functions to create
 * such attenuated / modified endowments. Otherwise, the value that's on the
 * root realm global will be used.
 *
 * @param wallet - The Snap's provider object.
 * @param endowments - The list of endowments to provide to the snap.
 * @returns An object containing the Snap's endowments.
 */
function createEndowments(wallet, endowments = []) {
    const attenuatedEndowments = {};
    // TODO: All endowments should be hardened to prevent covert communication
    // channels. Hardening the returned objects breaks tests elsewhere in the
    // monorepo, so further research is needed.
    const result = endowments.reduce(({ allEndowments, teardowns }, endowmentName) => {
        // First, check if the endowment has a factory, and default to that.
        if (endowmentFactories.has(endowmentName)) {
            if (!Object.hasOwnProperty.call(attenuatedEndowments, endowmentName)) {
                // Call the endowment factory for the current endowment. If the factory
                // creates multiple endowments, they will all be assigned to the
                // `attenuatedEndowments` object, but will only be passed on to the snap
                // if explicitly listed among its endowment.
                // This may not have an actual use case, but, safety first.
                // We just confirmed that endowmentFactories has the specified key.
                const { teardownFunction, ...endowment } = 
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                endowmentFactories.get(endowmentName)();
                Object.assign(attenuatedEndowments, endowment);
                if (teardownFunction) {
                    teardowns.push(teardownFunction);
                }
            }
            allEndowments[endowmentName] = attenuatedEndowments[endowmentName];
        }
        else if (endowmentName in globalObject_1.rootRealmGlobal) {
            // If the endowment doesn't have a factory, just use whatever is on the
            // global object.
            const globalValue = globalObject_1.rootRealmGlobal[endowmentName];
            allEndowments[endowmentName] =
                typeof globalValue === 'function' && !isConstructor(globalValue)
                    ? globalValue.bind(globalObject_1.rootRealmGlobal)
                    : globalValue;
        }
        else {
            // If we get to this point, we've been passed an endowment that doesn't
            // exist in our current environment.
            throw new Error(`Unknown endowment: "${endowmentName}".`);
        }
        return { allEndowments, teardowns };
    }, {
        allEndowments: { wallet },
        teardowns: [],
    });
    const teardown = () => result.teardowns.forEach((teardownFunction) => teardownFunction());
    return { endowments: result.allEndowments, teardown };
}
exports.createEndowments = createEndowments;
/**
 * Checks whether the specified function is a constructor.
 *
 * @param value - Any function value.
 * @returns Whether the specified function is a constructor.
 */
// `Function` is exactly what we want here.
// eslint-disable-next-line @typescript-eslint/ban-types
function isConstructor(value) {
    // In our current usage, the string `prototype.constructor.name` should never
    // be empty, because you can't create a class with no name, and the
    // `prototype.constructor.name` property is configurable but not writable.
    // Nevertheless, that property was the empty string for `Date` in the iframe
    // execution environment during local testing. We have no idea why, but we
    // have to handle that case.
    // TODO: Does the `prototype` object always have a `constructor` property?
    return Boolean(typeof value.prototype?.constructor?.name === 'string');
}
//# sourceMappingURL=index.js.map