{"version":3,"file":"BIP44Node.js","sourceRoot":"","sources":["../src/BIP44Node.ts"],"names":[],"mappings":"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","sourcesContent":["import { deriveKeyFromPath } from './derivation';\nimport {\n  MIN_BIP_44_DEPTH,\n  MAX_BIP_44_DEPTH,\n  BIP44Depth,\n  PartialHDPathTuple,\n  RootedHDPathTuple,\n  HDPathTuple,\n  BIP_39_PATH_REGEX,\n  BIP_32_PATH_REGEX,\n  BIP44PurposeNodeToken,\n} from './constants';\nimport {\n  bufferToBase64String,\n  base64StringToBuffer,\n  hexStringToBuffer,\n  isValidHexStringKey,\n  isValidBase64StringKey,\n  isValidBufferKey,\n  isHardened,\n} from './utils';\n\n/**\n * A wrapper for BIP-44 Hierarchical Deterministic (HD) tree nodes, i.e.\n * cryptographic keys used to generate keypairs and addresses for cryptocurrency\n * protocols.\n */\nexport interface JsonBIP44Node {\n  /**\n   * The 0-indexed BIP-44 path depth of this node.\n   *\n   * A BIP-44 path is of the form:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   */\n  readonly depth: BIP44Depth;\n\n  /**\n   * The Base64 string representation of the key material for this node.\n   */\n  readonly key: string;\n}\n\nexport type BIP44NodeInterface = JsonBIP44Node & {\n  /**\n   * The raw bytes of the key material for this node, as a Node.js Buffer or\n   * browser-equivalent.\n   */\n  keyBuffer: Buffer;\n\n  /**\n   * @returns A JSON-compatible representation of this node's data fields.\n   */\n  toJSON(): JsonBIP44Node;\n};\n\ninterface BIP44NodeOptions {\n  readonly depth?: BIP44Depth;\n  readonly key?: Buffer | string;\n  readonly derivationPath?: RootedHDPathTuple;\n}\n\n/**\n * A wrapper for BIP-44 Hierarchical Deterministic (HD) tree nodes, i.e.\n * cryptographic keys used to generate keypairs and addresses for cryptocurrency\n * protocols.\n *\n * This class contains methods and fields that may not serialize well. Use\n * {@link BIP44Node.toJSON} to get a JSON-compatible representation.\n */\nexport class BIP44Node implements BIP44NodeInterface {\n  public readonly depth: BIP44Depth;\n\n  public get key(): string {\n    return bufferToBase64String(this.keyBuffer);\n  }\n\n  public readonly keyBuffer: Buffer;\n\n  /**\n   * Initializes a BIP-44 node. Accepts either:\n   * - An existing 64-byte BIP-44 key, and its **0-indexed** BIP-44 path depth.\n   *   - The key may be in the form of a hexadecimal string, Base64 string, or a\n   *     {@link Buffer}.\n   * - A BIP-44 derivation path starting with an `m` node.\n   *   - At present, the `m` node must be a BIP-39 node, given as a string of\n   *     the form `bip39:MNEMONIC`, where `MNEMONIC` is a space-separated list\n   *     of BIP-39 seed phrase words.\n   *\n   * All parameters are stringently validated, and an error is thrown if\n   * validation fails.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param options - Options bag.\n   * @param options.depth - The 0-indexed BIP-44 tree depth of the `key`, if\n   * specified.\n   * @param options.key - The key of this node. Mutually exclusive with\n   * `derivationPath`, and requires a `depth` to be specified.\n   * @param options.derivationPath - The rooted HD tree path that will be used\n   * to derive the key of this node. Mutually exclusive with `key`.\n   */\n  constructor({ depth, key, derivationPath }: BIP44NodeOptions) {\n    const _key = BIP44Node._parseKey(key);\n\n    if (derivationPath) {\n      if (_key) {\n        throw new Error(\n          'Invalid parameters: May not specify a derivation path if a key is specified. Initialize the node with just the parent key and its depth, then call BIP44Node.derive() with your desired path.',\n        );\n      }\n\n      if (depth) {\n        throw new Error(\n          'Invalid parameters: May not specify a depth if a derivation path is specified. The depth will be calculated from the path.',\n        );\n      }\n\n      if ((derivationPath as any).length === 0) {\n        throw new Error(\n          'Invalid derivation path: May not specify an empty derivation path.',\n        );\n      }\n\n      const _depth = derivationPath.length - 1;\n      validateBIP44Depth(_depth);\n      this.depth = _depth as BIP44Depth;\n\n      validateBIP44DerivationPath(derivationPath, MIN_BIP_44_DEPTH);\n      this.keyBuffer = deriveKeyFromPath(derivationPath, undefined, this.depth);\n    } else if (_key) {\n      validateBIP44Depth(depth);\n      this.depth = depth as BIP44Depth;\n\n      this.keyBuffer = _key;\n    } else {\n      throw new Error(\n        'Invalid parameters: Must specify either key or derivation path.',\n      );\n    }\n\n    Object.freeze(this);\n  }\n\n  /**\n   * Constructor helper for validating and parsing the `key` parameter. An error\n   * is thrown if validation fails.\n   *\n   * @param key - The key to parse.\n   * @returns A {@link Buffer}, or `undefined` if no key parameter was\n   * specified.\n   */\n  private static _parseKey(key: unknown): Buffer | undefined {\n    if (key === undefined || key === null) {\n      return undefined;\n    }\n\n    let bufferKey: Buffer;\n    if (Buffer.isBuffer(key)) {\n      if (!isValidBufferKey(key)) {\n        throw new Error(\n          'Invalid buffer key: Must be a 64-byte, non-empty Buffer.',\n        );\n      }\n\n      bufferKey = key;\n    } else if (typeof key === 'string') {\n      if (isValidHexStringKey(key)) {\n        bufferKey = hexStringToBuffer(key);\n      } else if (isValidBase64StringKey(key)) {\n        bufferKey = base64StringToBuffer(key);\n      } else {\n        throw new Error(\n          'Invalid string key: Must be a 64-byte hexadecimal or Base64 string.',\n        );\n      }\n    } else {\n      throw new Error(\n        `Invalid key: Must be a Buffer or string if specified. Received: \"${typeof key}\"`,\n      );\n    }\n\n    return bufferKey;\n  }\n\n  /**\n   * Derives a child of the key contains be this node and returns a new\n   * {@link BIP44Node} containing the child key.\n   *\n   * The specified path must be a valid HD path from this node, per BIP-44.\n   * At present, this means that the path must consist of no more than 5 BIP-32\n   * nodes, depending on the depth of this node.\n   *\n   * Recall that a BIP-44 HD tree path consists of the following nodes:\n   *\n   * `m / 44' / coin_type' / account' / change / address_index`\n   *\n   * With the following depths:\n   *\n   * `0 / 1 / 2 / 3 / 4 / 5`\n   *\n   * @param path - The partial (non-rooted) BIP-44 HD tree path will be used\n   * to derive a child key from the parent key contained within this node.\n   * @returns The {@link BIP44Node} corresponding to the derived child key.\n   */\n  public derive(path: PartialHDPathTuple): BIP44Node {\n    if (this.depth === MAX_BIP_44_DEPTH) {\n      throw new Error(\n        'Illegal operation: This HD tree node is already a leaf node.',\n      );\n    }\n\n    return deriveChildNode(this.keyBuffer, this.depth, path);\n  }\n\n  // This is documented in the interface of this class.\n  toJSON(): JsonBIP44Node {\n    return {\n      depth: this.depth,\n      key: this.key,\n    };\n  }\n}\n\n/**\n * Derives a child key from the given parent key, as a {@link BIP44Node}.\n * @param parentKey - The parent key to derive from.\n * @param parentDepth - The depth of the parent key.\n * @param pathToChild - The path to the child node / key.\n * @returns The {@link BIP44Node} corresponding to the derived child key.\n */\nexport function deriveChildNode(\n  parentKey: Buffer,\n  parentDepth: BIP44Depth,\n  pathToChild: PartialHDPathTuple,\n) {\n  if ((pathToChild as any).length === 0) {\n    throw new Error(\n      'Invalid HD tree derivation path: Deriving a path of length 0 is not defined',\n    );\n  }\n\n  // Note that we do not subtract 1 from the length of the path to the child,\n  // unlike when we calculate the depth of a rooted path.\n  const newDepth = (parentDepth + pathToChild.length) as BIP44Depth;\n  validateBIP44Depth(newDepth);\n  validateBIP44DerivationPath(pathToChild, (parentDepth + 1) as BIP44Depth);\n\n  return new BIP44Node({\n    depth: newDepth,\n    key: deriveKeyFromPath(pathToChild, parentKey),\n  });\n}\n\n/**\n * Validates a BIP-44 path depth. Effectively, asserts that the depth is an\n * integer `number` N such that 0 <= N <= 5. Throws an error if validation\n * fails.\n *\n * @param depth - The depth to validate.\n */\nfunction validateBIP44Depth(depth: unknown) {\n  if (\n    typeof depth !== 'number' ||\n    !Number.isInteger(depth) ||\n    depth < MIN_BIP_44_DEPTH ||\n    depth > MAX_BIP_44_DEPTH\n  ) {\n    throw new Error(\n      `Invalid HD tree path depth: The depth must be a positive integer N such that 0 <= N <= 5. Received: \"${depth}\"`,\n    );\n  }\n}\n\n/**\n * Ensures that the given derivation is valid by BIP-44.\n *\n * Recall that a BIP-44 HD tree path consists of the following nodes:\n *\n * `m / 44' / coin_type' / account' / change / address_index`\n *\n * With the following depths:\n *\n * `0 / 1 / 2 / 3 / 4 / 5`\n *\n * @param path - The path to validate.\n * @param startingDepth - The depth of the first node of the derivation path.\n */\nfunction validateBIP44DerivationPath(\n  path: HDPathTuple,\n  startingDepth: BIP44Depth,\n) {\n  path.forEach((nodeToken, index) => {\n    const currentDepth = startingDepth + index;\n\n    switch (currentDepth) {\n      case MIN_BIP_44_DEPTH:\n        if (!BIP_39_PATH_REGEX.test(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"m\" / seed node (depth 0) must be a BIP-39 node.',\n          );\n        }\n        break;\n\n      case 1:\n        if (nodeToken !== BIP44PurposeNodeToken) {\n          throw new Error(\n            `Invalid derivation path: The \"purpose\" node node (depth 1) must be the string \"${BIP44PurposeNodeToken}\".`,\n          );\n        }\n        break;\n\n      case 2:\n        if (!BIP_32_PATH_REGEX.test(nodeToken) || !isHardened(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"coin_type\" node (depth 2) must be a hardened BIP-32 node.',\n          );\n        }\n        break;\n\n      case 3:\n        if (!BIP_32_PATH_REGEX.test(nodeToken) || !isHardened(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"account\" node (depth 3) must be a hardened BIP-32 node.',\n          );\n        }\n        break;\n\n      case 4:\n        if (!BIP_32_PATH_REGEX.test(nodeToken) || isHardened(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"change\" node (depth 4) must be an unhardened BIP-32 node.',\n          );\n        }\n        break;\n\n      case MAX_BIP_44_DEPTH: // 5\n        if (!BIP_32_PATH_REGEX.test(nodeToken) || isHardened(nodeToken)) {\n          throw new Error(\n            'Invalid derivation path: The \"address_index\" node (depth 5) must be an unhardened BIP-32 node.',\n          );\n        }\n        break;\n\n      /* istanbul ignore next: should be impossible in our usage */\n      default:\n        throw new Error(\n          `Invalid derivation path: The path exceeds the maximum BIP-44 depth.`,\n        );\n    }\n  });\n}\n"]}