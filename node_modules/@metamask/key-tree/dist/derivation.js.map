{"version":3,"file":"derivation.js","sourceRoot":"","sources":["../src/derivation.ts"],"names":[],"mappings":";;;AAAA,2CAOqB;AACrB,yCAA+C;AAE/C;;;;;;;;;;GAUG;AAEH;;;;;;;;;;;;;;;;;;GAkBG;AACH,SAAgB,iBAAiB,CAC/B,WAAwB,EACxB,SAAkB,EAClB,KAAkB;IAElB,IAAI,SAAS,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE;QAC5C,MAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC,CAAC;KAC9D;IACD,mBAAmB,CAAC,WAAW,EAAE,OAAO,CAAC,SAAS,CAAC,EAAE,KAAK,CAAC,CAAC;IAE5D,IAAI,GAAG,GAAG,SAAS,CAAC;IAEpB,mCAAmC;IACnC,WAAW,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QAC3B,MAAM,CAAC,QAAQ,EAAE,SAAS,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC9C,8CAA8C;QAC9C,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;YACzB,MAAM,IAAI,KAAK,CAAC,6BAA6B,QAAQ,GAAG,CAAC,CAAC;SAC3D;QACD,MAAM,OAAO,GAAG,mBAAQ,CAAC,QAAQ,CAAY,CAAC;QAC9C,MAAM,QAAQ,GAAG,OAAO,CAAC,cAAc,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;QACxD,mCAAmC;QACnC,GAAG,GAAG,QAAQ,CAAC;IACjB,CAAC,CAAC,CAAC;IAEH,OAAO,GAAa,CAAC;AACvB,CAAC;AA1BD,8CA0BC;AAED;;GAEG;AACH,SAAS,UAAU,CAAC,QAAgB;IAClC,OAAO,QAAQ,IAAI,mBAAQ,CAAC;AAC9B,CAAC;AAED;;;;;;;GAOG;AACH,SAAgB,mBAAmB,CACjC,WAAwB,EACxB,MAAe,EACf,KAAkB;IAElB,IAAK,WAAmB,CAAC,MAAM,KAAK,CAAC,EAAE;QACrC,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAC;KAC5E;IAED,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,GAAG,4BAAgB,EAAE;QAC7C,MAAM,IAAI,KAAK,CACb,4EAA4E,CAC7E,CAAC;KACH;IAED,IAAI,eAAe,GAAG,KAAK,CAAC;IAC5B,WAAW,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;QAClC,IAAI,KAAK,KAAK,CAAC,EAAE;YACf,eAAe,GAAG,6BAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC/C,IAAI,CAAC,eAAe,IAAI,CAAC,6BAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;gBACrD,MAAM,iBAAiB,EAAE,CAAC;aAC3B;SACF;aAAM,IAAI,CAAC,6BAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;YACxC,MAAM,iBAAiB,EAAE,CAAC;SAC3B;IACH,CAAC,CAAC,CAAC;IAEH,IACE,KAAK,KAAK,4BAAgB;QAC1B,CAAC,CAAC,eAAe,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,CAAC,EAC9C;QACA,MAAM,IAAI,KAAK,CACb,2FAA2F,4BAAgB,gBAAgB,WAAW,GAAG,CAC1I,CAAC;KACH;IAED,IAAI,CAAC,MAAM,IAAI,CAAC,eAAe,EAAE;QAC/B,MAAM,IAAI,KAAK,CACb,oHAAoH,CACrH,CAAC;KACH;IAED,IAAI,MAAM,IAAI,eAAe,EAAE;QAC7B,MAAM,IAAI,KAAK,CACb,0GAA0G,CAC3G,CAAC;KACH;AACH,CAAC;AA/CD,kDA+CC;AAED,SAAS,iBAAiB;IACxB,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAC;AAC7E,CAAC","sourcesContent":["import {\n  HDPathTuple,\n  BIP44Depth,\n  MAX_BIP_44_DEPTH,\n  MIN_BIP_44_DEPTH,\n  BIP_39_PATH_REGEX,\n  BIP_32_PATH_REGEX,\n} from './constants';\nimport { derivers, Deriver } from './derivers';\n\n/**\n * ethereum default seed path: \"m/44'/60'/0'/0/{account_index}\"\n * multipath: \"bip32:44'/bip32:60'/bip32:0'/bip32:0/bip32:{account_index}\"\n *\n * m: { privateKey, chainCode } = sha512Hmac(\"Bitcoin seed\", masterSeed)\n * 44': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])\n * 60': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])\n * 0': { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [0x00, parentKey.privateKey, index + HARDENED_OFFSET])\n * 0: { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [parentKey.publicKey, index])\n * 0: { privateKey, chainCode } = parentKey.privateKey + sha512Hmac(parentKey.chainCode, [parentKey.publicKey, index])\n */\n\n/**\n * Takes a full or partial HD path string and returns the key corresponding to\n * the given path, with the following constraints:\n *\n * - If the path starts with a BIP-32 node, a parent key must be provided.\n * - If the path starts with a BIP-39 node, a parent key must NOT be provided.\n * - The path cannot exceed 5 BIP-32 nodes in length, optionally preceded by\n *   a single BIP-39 node.\n *\n * WARNING: It is the consumer's responsibility to ensure that the path is valid\n * relative to its parent key.\n *\n * @param pathSegment - A full or partial HD path, e.g.:\n * bip39:SEED_PHRASE/bip32:44'/bip32:60'/bip32:0'/bip32:0/bip32:0\n *\n * BIP-39 seed phrases must be lowercase, space-delimited, and 12-24 words long.\n * @param parentKey - The parent key of the given path segment, if any.\n * @returns The derived key.\n */\nexport function deriveKeyFromPath(\n  pathSegment: HDPathTuple,\n  parentKey?: Buffer,\n  depth?: BIP44Depth,\n): Buffer {\n  if (parentKey && !Buffer.isBuffer(parentKey)) {\n    throw new Error('Parent key must be a Buffer if specified.');\n  }\n  validatePathSegment(pathSegment, Boolean(parentKey), depth);\n\n  let key = parentKey;\n\n  // derive through each part of path\n  pathSegment.forEach((node) => {\n    const [pathType, pathValue] = node.split(':');\n    /* istanbul ignore if: should be impossible */\n    if (!hasDeriver(pathType)) {\n      throw new Error(`Unknown derivation type: \"${pathType}\"`);\n    }\n    const deriver = derivers[pathType] as Deriver;\n    const childKey = deriver.deriveChildKey(pathValue, key);\n    // continue deriving from child key\n    key = childKey;\n  });\n\n  return key as Buffer;\n}\n\n/**\n * @param pathType\n */\nfunction hasDeriver(pathType: string): pathType is keyof typeof derivers {\n  return pathType in derivers;\n}\n\n/**\n * The path segment must be one of the following:\n * - A lone BIP-32 path node\n * - A lone BIP-39 path node\n * - A multipath\n *\n * @param pathSegment - The path segment string to validate.\n */\nexport function validatePathSegment(\n  pathSegment: HDPathTuple,\n  hasKey: boolean,\n  depth?: BIP44Depth,\n) {\n  if ((pathSegment as any).length === 0) {\n    throw new Error(`Invalid HD path segment: The segment must not be empty.`);\n  }\n\n  if (pathSegment.length - 1 > MAX_BIP_44_DEPTH) {\n    throw new Error(\n      `Invalid HD path segment: The segment cannot exceed a 0-indexed depth of 5.`,\n    );\n  }\n\n  let startsWithBip39 = false;\n  pathSegment.forEach((node, index) => {\n    if (index === 0) {\n      startsWithBip39 = BIP_39_PATH_REGEX.test(node);\n      if (!startsWithBip39 && !BIP_32_PATH_REGEX.test(node)) {\n        throw getMalformedError();\n      }\n    } else if (!BIP_32_PATH_REGEX.test(node)) {\n      throw getMalformedError();\n    }\n  });\n\n  if (\n    depth === MIN_BIP_44_DEPTH &&\n    (!startsWithBip39 || pathSegment.length !== 1)\n  ) {\n    throw new Error(\n      `Invalid HD path segment: The segment must consist of a single BIP-39 node for depths of ${MIN_BIP_44_DEPTH}. Received: \"${pathSegment}\"`,\n    );\n  }\n\n  if (!hasKey && !startsWithBip39) {\n    throw new Error(\n      'Invalid derivation parameters: Must specify parent key if the first node of the path segment is not a BIP-39 node.',\n    );\n  }\n\n  if (hasKey && startsWithBip39) {\n    throw new Error(\n      'Invalid derivation parameters: May not specify parent key if the path segment starts with a BIP-39 node.',\n    );\n  }\n}\n\nfunction getMalformedError() {\n  throw new Error('Invalid HD path segment: The path segment is malformed.');\n}\n"]}