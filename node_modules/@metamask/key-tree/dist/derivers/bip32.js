"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveChildKey = exports.privateKeyToEthAddress = void 0;
const crypto_1 = __importDefault(require("crypto"));
const secp256k1_1 = __importDefault(require("secp256k1"));
const keccak_1 = __importDefault(require("keccak"));
const constants_1 = require("../constants");
const utils_1 = require("../utils");
const HARDENED_OFFSET = 0x80000000;
/**
 * Converts a BIP-32 private key to an Ethereum address.
 *
 * **WARNING:** Only validates that the key is non-zero and of the correct
 * length. It is the consumer's responsibility to ensure that the specified
 * key is a valid BIP-44 Ethereum `address_index` key.
 *
 * @param key - The `address_index` key buffer to convert to an Ethereum
 * address.
 * @returns The Ethereum address corresponding to the given key.
 */
function privateKeyToEthAddress(key) {
    if (!Buffer.isBuffer(key) || !utils_1.isValidBufferKey(key)) {
        throw new Error('Invalid key: The key must be a 64-byte, non-zero Buffer.');
    }
    const privateKey = key.slice(0, 32);
    const publicKey = secp256k1_1.default
        .publicKeyCreate(new Uint8Array(privateKey), false)
        .slice(1);
    return keccak(Buffer.from(publicKey)).slice(-20);
}
exports.privateKeyToEthAddress = privateKeyToEthAddress;
/**
 * @param data
 * @param keccakBits
 */
function keccak(data, keccakBits = '256') {
    return keccak_1.default(`keccak${keccakBits}`).update(data).digest();
}
/**
 * @param pathPart
 * @param parentKey
 */
function deriveChildKey(pathPart, parentKey) {
    if (!parentKey) {
        throw new Error('Invalid parameters: Must specify a parent key.');
    }
    if (parentKey.length !== constants_1.BUFFER_KEY_LENGTH) {
        throw new Error('Invalid parent key: Must be 64 bytes long.');
    }
    const isHardened = pathPart.includes(`'`);
    const indexPart = pathPart.split(`'`)[0];
    const childIndex = parseInt(indexPart, 10);
    if (!/^\d+$/u.test(indexPart) ||
        !Number.isInteger(childIndex) ||
        childIndex < 0 ||
        childIndex >= HARDENED_OFFSET) {
        throw new Error(`Invalid BIP-32 index: The index must be a non-negative decimal integer less than ${HARDENED_OFFSET}.`);
    }
    const parentPrivateKey = parentKey.slice(0, 32);
    const parentExtraEntropy = parentKey.slice(32);
    const secretExtension = deriveSecretExtension({
        parentPrivateKey,
        childIndex,
        isHardened,
    });
    const { privateKey, extraEntropy } = generateKey({
        parentPrivateKey,
        parentExtraEntropy,
        secretExtension,
    });
    return Buffer.concat([privateKey, extraEntropy]);
}
exports.deriveChildKey = deriveChildKey;
// the bip32 secret extension is created from the parent private or public key and the child index
/**
 * @param options
 * @param options.parentPrivateKey
 * @param options.childIndex
 * @param options.isHardened
 */
function deriveSecretExtension({ parentPrivateKey, childIndex, isHardened, }) {
    if (isHardened) {
        // Hardened child
        const indexBuffer = Buffer.allocUnsafe(4);
        indexBuffer.writeUInt32BE(childIndex + HARDENED_OFFSET, 0);
        const pk = parentPrivateKey;
        const zb = Buffer.alloc(1, 0);
        return Buffer.concat([zb, pk, indexBuffer]);
    }
    // Normal child
    const indexBuffer = Buffer.allocUnsafe(4);
    indexBuffer.writeUInt32BE(childIndex, 0);
    const parentPublicKey = secp256k1_1.default.publicKeyCreate(new Uint8Array(parentPrivateKey), true);
    return Buffer.concat([parentPublicKey, indexBuffer]);
}
/**
 * @param options
 * @param options.parentPrivateKey
 * @param options.parentExtraEntropy
 * @param options.secretExtension
 */
function generateKey({ parentPrivateKey, parentExtraEntropy, secretExtension, }) {
    const entropy = crypto_1.default
        .createHmac('sha512', parentExtraEntropy)
        .update(secretExtension)
        .digest();
    const keyMaterial = entropy.slice(0, 32);
    // extraEntropy is also called "chaincode"
    const extraEntropy = entropy.slice(32);
    const privateKey = secp256k1_1.default.privateKeyTweakAdd(new Uint8Array(parentPrivateKey), new Uint8Array(keyMaterial));
    return { privateKey, extraEntropy };
}
//# sourceMappingURL=bip32.js.map