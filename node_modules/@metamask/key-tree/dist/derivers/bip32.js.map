{"version":3,"file":"bip32.js","sourceRoot":"","sources":["../../src/derivers/bip32.ts"],"names":[],"mappings":"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","sourcesContent":["import crypto from 'crypto';\nimport secp256k1 from 'secp256k1';\nimport createKeccakHash from 'keccak';\nimport { BUFFER_KEY_LENGTH } from '../constants';\nimport { isValidBufferKey } from '../utils';\n\nconst HARDENED_OFFSET = 0x80000000;\n\ntype KeccakBits = '224' | '256' | '384' | '512';\n\n/**\n * Converts a BIP-32 private key to an Ethereum address.\n *\n * **WARNING:** Only validates that the key is non-zero and of the correct\n * length. It is the consumer's responsibility to ensure that the specified\n * key is a valid BIP-44 Ethereum `address_index` key.\n *\n * @param key - The `address_index` key buffer to convert to an Ethereum\n * address.\n * @returns The Ethereum address corresponding to the given key.\n */\nexport function privateKeyToEthAddress(key: Buffer) {\n  if (!Buffer.isBuffer(key) || !isValidBufferKey(key)) {\n    throw new Error('Invalid key: The key must be a 64-byte, non-zero Buffer.');\n  }\n\n  const privateKey = key.slice(0, 32);\n  const publicKey = secp256k1\n    .publicKeyCreate(new Uint8Array(privateKey), false)\n    .slice(1);\n  return keccak(Buffer.from(publicKey)).slice(-20);\n}\n\n/**\n * @param data\n * @param keccakBits\n */\nfunction keccak(data: string | Buffer, keccakBits: KeccakBits = '256'): Buffer {\n  return createKeccakHash(`keccak${keccakBits}`).update(data).digest();\n}\n\n/**\n * @param pathPart\n * @param parentKey\n */\nexport function deriveChildKey(pathPart: string, parentKey: Buffer): Buffer {\n  if (!parentKey) {\n    throw new Error('Invalid parameters: Must specify a parent key.');\n  }\n\n  if (parentKey.length !== BUFFER_KEY_LENGTH) {\n    throw new Error('Invalid parent key: Must be 64 bytes long.');\n  }\n\n  const isHardened = pathPart.includes(`'`);\n  const indexPart = pathPart.split(`'`)[0];\n  const childIndex = parseInt(indexPart, 10);\n\n  if (\n    !/^\\d+$/u.test(indexPart) ||\n    !Number.isInteger(childIndex) ||\n    childIndex < 0 ||\n    childIndex >= HARDENED_OFFSET\n  ) {\n    throw new Error(\n      `Invalid BIP-32 index: The index must be a non-negative decimal integer less than ${HARDENED_OFFSET}.`,\n    );\n  }\n\n  const parentPrivateKey = parentKey.slice(0, 32);\n  const parentExtraEntropy = parentKey.slice(32);\n  const secretExtension = deriveSecretExtension({\n    parentPrivateKey,\n    childIndex,\n    isHardened,\n  });\n\n  const { privateKey, extraEntropy } = generateKey({\n    parentPrivateKey,\n    parentExtraEntropy,\n    secretExtension,\n  });\n\n  return Buffer.concat([privateKey, extraEntropy]);\n}\n\ninterface DeriveSecretExtensionArgs {\n  parentPrivateKey: Buffer;\n  childIndex: number;\n  isHardened: boolean;\n}\n\n// the bip32 secret extension is created from the parent private or public key and the child index\n/**\n * @param options\n * @param options.parentPrivateKey\n * @param options.childIndex\n * @param options.isHardened\n */\nfunction deriveSecretExtension({\n  parentPrivateKey,\n  childIndex,\n  isHardened,\n}: DeriveSecretExtensionArgs) {\n  if (isHardened) {\n    // Hardened child\n    const indexBuffer = Buffer.allocUnsafe(4);\n    indexBuffer.writeUInt32BE(childIndex + HARDENED_OFFSET, 0);\n    const pk = parentPrivateKey;\n    const zb = Buffer.alloc(1, 0);\n    return Buffer.concat([zb, pk, indexBuffer]);\n  }\n\n  // Normal child\n  const indexBuffer = Buffer.allocUnsafe(4);\n  indexBuffer.writeUInt32BE(childIndex, 0);\n  const parentPublicKey = secp256k1.publicKeyCreate(\n    new Uint8Array(parentPrivateKey),\n    true,\n  );\n  return Buffer.concat([parentPublicKey, indexBuffer]);\n}\n\ninterface GenerateKeyArgs {\n  parentPrivateKey: Buffer;\n  parentExtraEntropy: string | Buffer;\n  secretExtension: string | Buffer;\n}\n\n/**\n * @param options\n * @param options.parentPrivateKey\n * @param options.parentExtraEntropy\n * @param options.secretExtension\n */\nfunction generateKey({\n  parentPrivateKey,\n  parentExtraEntropy,\n  secretExtension,\n}: GenerateKeyArgs) {\n  const entropy = crypto\n    .createHmac('sha512', parentExtraEntropy)\n    .update(secretExtension)\n    .digest();\n  const keyMaterial = entropy.slice(0, 32);\n  // extraEntropy is also called \"chaincode\"\n  const extraEntropy = entropy.slice(32);\n  const privateKey = secp256k1.privateKeyTweakAdd(\n    new Uint8Array(parentPrivateKey),\n    new Uint8Array(keyMaterial),\n  );\n  return { privateKey, extraEntropy };\n}\n"]}