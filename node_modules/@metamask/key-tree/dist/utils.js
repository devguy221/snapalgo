"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidBase64StringKey = exports.isValidHexStringKey = exports.isValidBufferKey = exports.bufferToBase64String = exports.hexStringToBuffer = exports.base64StringToBuffer = exports.isValidHexString = exports.stripHexPrefix = exports.isHardened = exports.isValidBIP32Index = exports.validateBIP32Index = exports.getUnhardenedBIP32NodeToken = exports.getHardenedBIP32NodeToken = exports.getBIP44CoinTypeToAddressPathTuple = exports.getBIP44ChangePathString = exports.getBIP44CoinTypePathString = void 0;
const constants_1 = require("./constants");
/**
 * Gets a string representation of a BIP-44 path of depth 2, i.e.:
 * `m / 44' / coin_type'`
 *
 * For display purposes only.
 *
 * @param coin_type - The `coin_type` index to create a path visualization for.
 * @returns The visualization of the BIP-44 path for thte specified `coin_type`.
 */
function getBIP44CoinTypePathString(coin_type) {
    return `m / ${constants_1.BIP44PurposeNodeToken} / ${getUnhardenedBIP32NodeToken(coin_type)}'`;
}
exports.getBIP44CoinTypePathString = getBIP44CoinTypePathString;
/**
 * Gets a string representation of a BIP-44 path of depth 4, i.e.:
 * `m / 44' / coin_type' / account' / change`
 *
 * For display purposes only.
 *
 * @param coinTypePath - The parent `coin_type` path.
 * @param coin_type - The `change` index to create a path visualization for.
 * @returns The visualization of the BIP-44 path for the specified `coin_type`
 * and `change` indices.
 */
function getBIP44ChangePathString(coinTypePath, indices) {
    return `${coinTypePath} / ${getHardenedBIP32NodeToken(indices.account || 0)} / ${getUnhardenedBIP32NodeToken(indices.change || 0)}`;
}
exports.getBIP44ChangePathString = getBIP44ChangePathString;
/**
 * Gets a BIP-44 path tuple of the form `account' / change / address_index`,
 * which can be used to derive address keys together with a `coin_type` key.
 *
 * @param indices - The BIP-44 derivation index values.
 * @param indices.account - The `account` index value.
 * @param indices.change - The `change` index value.
 * @param indices.address_index - The `address_index` index value.
 * @returns The `account' / change / address_index` path corresponding to the
 * specified indices.
 */
function getBIP44CoinTypeToAddressPathTuple({ account = 0, change = 0, address_index, }) {
    return [
        getHardenedBIP32NodeToken(account),
        getUnhardenedBIP32NodeToken(change),
        getUnhardenedBIP32NodeToken(address_index),
    ];
}
exports.getBIP44CoinTypeToAddressPathTuple = getBIP44CoinTypeToAddressPathTuple;
/**
 * A hardened BIP-32 node token, e.g. `bip32:0'`.
 * Validates that the index is a non-negative integer number, and throws an
 * error if validation fails.
 *
 * @param index - The index of the node.
 * @returns The hardened BIP-32 node token.
 */
function getHardenedBIP32NodeToken(index) {
    validateBIP32Index(index);
    return `${getUnhardenedBIP32NodeToken(index)}'`;
}
exports.getHardenedBIP32NodeToken = getHardenedBIP32NodeToken;
/**
 * An unhardened BIP-32 node token, e.g. `bip32:0`.
 * Validates that the index is a non-negative integer number, and throws an
 * error if validation fails.
 *
 * @param index - The index of the node.
 * @returns The unhardened BIP-32 node token.
 */
function getUnhardenedBIP32NodeToken(index) {
    validateBIP32Index(index);
    return `bip32:${index}`;
}
exports.getUnhardenedBIP32NodeToken = getUnhardenedBIP32NodeToken;
/**
 * Validates that the index is a non-negative integer number. Throws an
 * error if validation fails.
 *
 * @param addressIndex - The index to validate.
 */
function validateBIP32Index(addressIndex) {
    if (!isValidBIP32Index(addressIndex)) {
        throw new Error(`Invalid BIP-32 index: Must be a non-negative integer.`);
    }
}
exports.validateBIP32Index = validateBIP32Index;
/**
 * @param index - The BIP-32 index to test.
 * @returns Whether the index is a non-negative integer number.
 */
function isValidBIP32Index(index) {
    return Number.isInteger(index) && index >= 0;
}
exports.isValidBIP32Index = isValidBIP32Index;
/**
 * @param bip32Token - The token to test.
 * @returns Whether the token is hardened, i.e. ends with `'`.
 */
function isHardened(bip32Token) {
    return bip32Token.endsWith(`'`);
}
exports.isHardened = isHardened;
/**
 * @param hexString - The hexadecimal string to strip.
 * @returns The hexadecimal string, without a `0x`-prefix, if any.
 */
function stripHexPrefix(hexString) {
    return hexString.replace(/^0x/iu, '');
}
exports.stripHexPrefix = stripHexPrefix;
/**
 * Tests whether the specified string is a valid hexadecimal string. The string
 * may or may not be `0x`-prefixed, and the test is case-insensitive.
 *
 * @param hexString - The string to test.
 * @returns Whether the specified string is a valid hexadecimal string. The
 * string may or may not be `0x`-prefixed.
 */
function isValidHexString(hexString) {
    return /^(?:0x)?[a-f0-9]+$/iu.test(hexString);
}
exports.isValidHexString = isValidHexString;
/**
 * @param base64String - The Base64 string to convert.
 * @returns The {@link Buffer} corresponding to the Base64 string.
 */
function base64StringToBuffer(base64String) {
    return Buffer.from(base64String, 'base64');
}
exports.base64StringToBuffer = base64StringToBuffer;
/**
 * @param hexString - The hexadecimal string to convert.
 * @returns The {@link Buffer} corresponding to the hexadecimal string.
 */
function hexStringToBuffer(hexString) {
    return Buffer.from(stripHexPrefix(hexString), 'hex');
}
exports.hexStringToBuffer = hexStringToBuffer;
/**
 * @param input - The {@link Buffer} to convert.
 * @returns The buffer as a Base64 string.
 */
function bufferToBase64String(input) {
    return input.toString('base64');
}
exports.bufferToBase64String = bufferToBase64String;
/**
 * Tests whether the specified {@link Buffer} is a valid BIP-32 key.
 * A valid buffer key is 64 bytes long and has at least one non-zero byte.
 *
 * @param buffer - The {@link Buffer} to test.
 * @returns Whether the buffer represents a valid BIP-32 key.
 */
function isValidBufferKey(buffer) {
    if (buffer.length !== constants_1.BUFFER_KEY_LENGTH) {
        return false;
    }
    for (const byte of buffer) {
        if (byte !== 0) {
            return true;
        }
    }
    return false;
}
exports.isValidBufferKey = isValidBufferKey;
/**
 * @param input - The string to test.
 * @returns Whether the given string is a valid Base64 string.
 */
function isValidBase64String(input) {
    return constants_1.BASE_64_REGEX.test(input);
}
/**
 * Tests whether the specified hexadecimal string is a valid BIP-32 key.
 * A valid hexadecimal string key is 128 characters long (excluding any `0x`
 * prefix) and has at least one non-zero byte.
 *
 * @param stringKey - The hexadecimal string to test.
 * @returns Whether the string represents a valid BIP-32 key.
 */
function isValidHexStringKey(stringKey) {
    if (!isValidHexString(stringKey)) {
        return false;
    }
    const stripped = stripHexPrefix(stringKey);
    if (stripped.length !== constants_1.HEXADECIMAL_KEY_LENGTH) {
        return false;
    }
    if (/^0+$/iu.test(stripped)) {
        return false;
    }
    return true;
}
exports.isValidHexStringKey = isValidHexStringKey;
/**
 * Tests whether the specified Base64 string is a valid BIP-32 key.
 * A valid Base64 string key is 88 characters long and has at least one non-zero
 * byte.
 *
 * @param stringKey - The Base64 string to test.
 * @returns Whether the string represents a valid BIP-32 key.
 */
function isValidBase64StringKey(stringKey) {
    if (!isValidBase64String(stringKey)) {
        return false;
    }
    if (stringKey.length !== constants_1.BASE_64_KEY_LENGTH) {
        return false;
    }
    if (stringKey === constants_1.BASE_64_ZERO) {
        return false;
    }
    return true;
}
exports.isValidBase64StringKey = isValidBase64StringKey;
//# sourceMappingURL=utils.js.map