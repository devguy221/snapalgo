{"version":3,"file":"utils.js","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  BASE_64_KEY_LENGTH,\n  BASE_64_REGEX,\n  BASE_64_ZERO,\n  BUFFER_KEY_LENGTH,\n  BIP44PurposeNodeToken,\n  UnhardenedBIP32Node,\n  CoinTypeHDPathString,\n  CoinTypeToAddressTuple,\n  HardenedBIP32Node,\n  ChangeHDPathString,\n  HEXADECIMAL_KEY_LENGTH,\n} from './constants';\n\n/**\n * Gets a string representation of a BIP-44 path of depth 2, i.e.:\n * `m / 44' / coin_type'`\n *\n * For display purposes only.\n *\n * @param coin_type - The `coin_type` index to create a path visualization for.\n * @returns The visualization of the BIP-44 path for thte specified `coin_type`.\n */\nexport function getBIP44CoinTypePathString(\n  coin_type: number,\n): CoinTypeHDPathString {\n  return `m / ${BIP44PurposeNodeToken} / ${getUnhardenedBIP32NodeToken(\n    coin_type,\n  )}'`;\n}\n\ninterface BIP44PathIndices {\n  coin_type: number;\n  account?: number;\n  change?: number;\n  address_index: number;\n}\n\nexport type CoinTypeToAddressIndices = Pick<\n  BIP44PathIndices,\n  'account' | 'change' | 'address_index'\n>;\n\n/**\n * Gets a string representation of a BIP-44 path of depth 4, i.e.:\n * `m / 44' / coin_type' / account' / change`\n *\n * For display purposes only.\n *\n * @param coinTypePath - The parent `coin_type` path.\n * @param coin_type - The `change` index to create a path visualization for.\n * @returns The visualization of the BIP-44 path for the specified `coin_type`\n * and `change` indices.\n */\nexport function getBIP44ChangePathString(\n  coinTypePath: CoinTypeHDPathString,\n  indices: Omit<CoinTypeToAddressIndices, 'address_index'>,\n): ChangeHDPathString {\n  return `${coinTypePath} / ${getHardenedBIP32NodeToken(\n    indices.account || 0,\n  )} / ${getUnhardenedBIP32NodeToken(indices.change || 0)}`;\n}\n\n/**\n * Gets a BIP-44 path tuple of the form `account' / change / address_index`,\n * which can be used to derive address keys together with a `coin_type` key.\n *\n * @param indices - The BIP-44 derivation index values.\n * @param indices.account - The `account` index value.\n * @param indices.change - The `change` index value.\n * @param indices.address_index - The `address_index` index value.\n * @returns The `account' / change / address_index` path corresponding to the\n * specified indices.\n */\nexport function getBIP44CoinTypeToAddressPathTuple({\n  account = 0,\n  change = 0,\n  address_index,\n}: CoinTypeToAddressIndices): CoinTypeToAddressTuple {\n  return [\n    getHardenedBIP32NodeToken(account),\n    getUnhardenedBIP32NodeToken(change),\n    getUnhardenedBIP32NodeToken(address_index),\n  ] as const;\n}\n\n/**\n * A hardened BIP-32 node token, e.g. `bip32:0'`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The hardened BIP-32 node token.\n */\nexport function getHardenedBIP32NodeToken(index: number): HardenedBIP32Node {\n  validateBIP32Index(index);\n  return `${getUnhardenedBIP32NodeToken(index)}'`;\n}\n\n/**\n * An unhardened BIP-32 node token, e.g. `bip32:0`.\n * Validates that the index is a non-negative integer number, and throws an\n * error if validation fails.\n *\n * @param index - The index of the node.\n * @returns The unhardened BIP-32 node token.\n */\nexport function getUnhardenedBIP32NodeToken(\n  index: number,\n): UnhardenedBIP32Node {\n  validateBIP32Index(index);\n  return `bip32:${index}`;\n}\n\n/**\n * Validates that the index is a non-negative integer number. Throws an\n * error if validation fails.\n *\n * @param addressIndex - The index to validate.\n */\nexport function validateBIP32Index(addressIndex: number) {\n  if (!isValidBIP32Index(addressIndex)) {\n    throw new Error(`Invalid BIP-32 index: Must be a non-negative integer.`);\n  }\n}\n\n/**\n * @param index - The BIP-32 index to test.\n * @returns Whether the index is a non-negative integer number.\n */\nexport function isValidBIP32Index(index: number): boolean {\n  return Number.isInteger(index) && index >= 0;\n}\n\n/**\n * @param bip32Token - The token to test.\n * @returns Whether the token is hardened, i.e. ends with `'`.\n */\nexport function isHardened(bip32Token: string): boolean {\n  return bip32Token.endsWith(`'`);\n}\n\n/**\n * @param hexString - The hexadecimal string to strip.\n * @returns The hexadecimal string, without a `0x`-prefix, if any.\n */\nexport function stripHexPrefix(hexString: string): string {\n  return hexString.replace(/^0x/iu, '');\n}\n\n/**\n * Tests whether the specified string is a valid hexadecimal string. The string\n * may or may not be `0x`-prefixed, and the test is case-insensitive.\n *\n * @param hexString - The string to test.\n * @returns Whether the specified string is a valid hexadecimal string. The\n * string may or may not be `0x`-prefixed.\n */\nexport function isValidHexString(hexString: string): boolean {\n  return /^(?:0x)?[a-f0-9]+$/iu.test(hexString);\n}\n\n/**\n * @param base64String - The Base64 string to convert.\n * @returns The {@link Buffer} corresponding to the Base64 string.\n */\nexport function base64StringToBuffer(base64String: string): Buffer {\n  return Buffer.from(base64String, 'base64');\n}\n\n/**\n * @param hexString - The hexadecimal string to convert.\n * @returns The {@link Buffer} corresponding to the hexadecimal string.\n */\nexport function hexStringToBuffer(hexString: string): Buffer {\n  return Buffer.from(stripHexPrefix(hexString), 'hex');\n}\n\n/**\n * @param input - The {@link Buffer} to convert.\n * @returns The buffer as a Base64 string.\n */\nexport function bufferToBase64String(input: Buffer): string {\n  return input.toString('base64');\n}\n\n/**\n * Tests whether the specified {@link Buffer} is a valid BIP-32 key.\n * A valid buffer key is 64 bytes long and has at least one non-zero byte.\n *\n * @param buffer - The {@link Buffer} to test.\n * @returns Whether the buffer represents a valid BIP-32 key.\n */\nexport function isValidBufferKey(buffer: Buffer): boolean {\n  if (buffer.length !== BUFFER_KEY_LENGTH) {\n    return false;\n  }\n\n  for (const byte of buffer) {\n    if (byte !== 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * @param input - The string to test.\n * @returns Whether the given string is a valid Base64 string.\n */\nfunction isValidBase64String(input: string) {\n  return BASE_64_REGEX.test(input);\n}\n\n/**\n * Tests whether the specified hexadecimal string is a valid BIP-32 key.\n * A valid hexadecimal string key is 128 characters long (excluding any `0x`\n * prefix) and has at least one non-zero byte.\n *\n * @param stringKey - The hexadecimal string to test.\n * @returns Whether the string represents a valid BIP-32 key.\n */\nexport function isValidHexStringKey(stringKey: string): boolean {\n  if (!isValidHexString(stringKey)) {\n    return false;\n  }\n\n  const stripped = stripHexPrefix(stringKey);\n  if (stripped.length !== HEXADECIMAL_KEY_LENGTH) {\n    return false;\n  }\n\n  if (/^0+$/iu.test(stripped)) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Tests whether the specified Base64 string is a valid BIP-32 key.\n * A valid Base64 string key is 88 characters long and has at least one non-zero\n * byte.\n *\n * @param stringKey - The Base64 string to test.\n * @returns Whether the string represents a valid BIP-32 key.\n */\nexport function isValidBase64StringKey(stringKey: string): boolean {\n  if (!isValidBase64String(stringKey)) {\n    return false;\n  }\n\n  if (stringKey.length !== BASE_64_KEY_LENGTH) {\n    return false;\n  }\n\n  if (stringKey === BASE_64_ZERO) {\n    return false;\n  }\n  return true;\n}\n"]}