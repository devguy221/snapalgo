/// <reference types="node" />
import { Duplex } from 'stream';
import ObjectMultiplex from '@metamask/object-multiplex';
import { ExecutionServiceMessenger, SnapExecutionData } from '@metamask/snap-types';
import { JsonRpcEngine, JsonRpcRequest } from 'json-rpc-engine';
import { ExecutionService } from '.';
export declare type SetupSnapProvider = (snapId: string, stream: Duplex) => void;
declare type ExecutionServiceArgs = {
    setupSnapProvider: SetupSnapProvider;
    messenger: ExecutionServiceMessenger;
    terminationTimeout?: number;
};
export declare type SnapRpcHook = (origin: string, request: Record<string, unknown>) => Promise<unknown>;
interface JobStreams {
    rpc: Duplex | null;
}
declare type Job = {
    id: string;
    streams: JobStreams;
    rpcEngine: JsonRpcEngine;
};
export declare abstract class AbstractExecutionService<JobType extends Job> implements ExecutionService {
    protected _snapRpcHooks: Map<string, SnapRpcHook>;
    protected jobs: Map<string, JobType>;
    protected setupSnapProvider: SetupSnapProvider;
    protected snapToJobMap: Map<string, string>;
    protected jobToSnapMap: Map<string, string>;
    protected _messenger: ExecutionServiceMessenger;
    protected _terminationTimeout: number;
    constructor({ setupSnapProvider, messenger, terminationTimeout, }: ExecutionServiceArgs);
    /**
     * Performs additional necessary work during job termination. **MUST** be
     * implemented by concrete implementations. See
     * {@link AbstractExecutionService.terminate} for details.
     *
     * @param job - The object corresponding to the job to be terminated.
     */
    protected abstract _terminate(job: JobType): void;
    /**
     * Terminates the job with the specified ID and deletes all its associated
     * data. Any subsequent messages targeting the job will fail with an error.
     * Throws an error if the specified job does not exist, or if termination
     * fails unexpectedly.
     *
     * @param jobId - The id of the job to be terminated.
     */
    terminate(jobId: string): Promise<void>;
    /**
     * Abstract function implemented by implementing class that spins up a new worker for a job.
     *
     * Depending on the execution environment, this may run forever if the Snap fails to start up properly, therefore any call to this function should be wrapped in a timeout.
     */
    protected abstract _initJob(): Promise<JobType>;
    /**
     * Terminates the Snap with the specified ID. May throw an error if
     * termination unexpectedly fails, but will not fail if no job for the snap
     * with the specified ID is found.
     *
     * @param snapId - The ID of the snap to terminate.
     */
    terminateSnap(snapId: string): Promise<void>;
    terminateAllSnaps(): Promise<void>;
    /**
     * Gets the RPC message handler for the given snap.
     *
     * @param snapId - The id of the Snap whose message handler to get.
     */
    getRpcMessageHandler(snapId: string): Promise<SnapRpcHook | undefined>;
    /**
     * Initializes and executes a snap, setting up the communication channels to the snap etc.
     *
     * Depending on the execution environment, this may run forever if the Snap fails to start up properly, therefore any call to this function should be wrapped in a timeout.
     *
     * @param snapData - Data needed for Snap execution.
     */
    executeSnap(snapData: SnapExecutionData): Promise<unknown>;
    protected _command(jobId: string, message: JsonRpcRequest<unknown>): Promise<unknown>;
    protected _removeSnapHooks(snapId: string): void;
    protected _createSnapHooks(snapId: string, workerId: string): void;
    /**
     * @returns The ID of the snap's job.
     */
    protected _getJobForSnap(snapId: string): string | undefined;
    /**
     * @returns The ID jobs's snap.
     */
    _getSnapForJob(jobId: string): string | undefined;
    protected _mapSnapAndJob(snapId: string, jobId: string): void;
    protected _removeSnapAndJobMapping(jobId: string): void;
}
/**
 * Sets up stream multiplexing for the given stream.
 *
 * @param connectionStream - the stream to mux
 * @param streamName - the name of the stream, for identification in errors
 * @return {stream.Stream} the multiplexed stream
 */
export declare function setupMultiplex(connectionStream: Duplex, streamName: string): ObjectMultiplex;
export {};
