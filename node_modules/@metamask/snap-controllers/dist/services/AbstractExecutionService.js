"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupMultiplex = exports.AbstractExecutionService = void 0;
const object_multiplex_1 = __importDefault(require("@metamask/object-multiplex"));
const utils_1 = require("@metamask/utils");
const nanoid_1 = require("nanoid");
const pump_1 = __importDefault(require("pump"));
class AbstractExecutionService {
    constructor({ setupSnapProvider, messenger, terminationTimeout = utils_1.Duration.Second, }) {
        this._snapRpcHooks = new Map();
        this.jobs = new Map();
        this.setupSnapProvider = setupSnapProvider;
        this.snapToJobMap = new Map();
        this.jobToSnapMap = new Map();
        this._messenger = messenger;
        this._terminationTimeout = terminationTimeout;
    }
    /**
     * Terminates the job with the specified ID and deletes all its associated
     * data. Any subsequent messages targeting the job will fail with an error.
     * Throws an error if the specified job does not exist, or if termination
     * fails unexpectedly.
     *
     * @param jobId - The id of the job to be terminated.
     */
    async terminate(jobId) {
        const jobWrapper = this.jobs.get(jobId);
        if (!jobWrapper) {
            throw new Error(`Job with id "${jobId}" not found.`);
        }
        let terminationTimeout;
        const terminationTimeoutPromise = new Promise((resolve) => {
            terminationTimeout = setTimeout(() => {
                // No need to reject here, we just resolve and move on if the terminate request doesn't respond quickly
                resolve();
            }, this._terminationTimeout);
        });
        // Ping worker and tell it to run teardown, continue with termination if it takes too long
        try {
            await Promise.race([
                this._command(jobId, {
                    jsonrpc: '2.0',
                    method: 'terminate',
                    params: [],
                    id: (0, nanoid_1.nanoid)(),
                }),
                terminationTimeoutPromise,
            ]);
        }
        catch (error) {
            console.error(`Job "${jobId}" failed to terminate gracefully.`, error);
        }
        clearTimeout(terminationTimeout);
        Object.values(jobWrapper.streams).forEach((stream) => {
            try {
                !stream.destroyed && stream.destroy();
                stream.removeAllListeners();
            }
            catch (err) {
                console.error('Error while destroying stream', err);
            }
        });
        this._terminate(jobWrapper);
        this._removeSnapAndJobMapping(jobId);
        this.jobs.delete(jobId);
        console.log(`job: "${jobId}" terminated`);
    }
    /**
     * Terminates the Snap with the specified ID. May throw an error if
     * termination unexpectedly fails, but will not fail if no job for the snap
     * with the specified ID is found.
     *
     * @param snapId - The ID of the snap to terminate.
     */
    async terminateSnap(snapId) {
        const jobId = this.snapToJobMap.get(snapId);
        if (jobId) {
            await this.terminate(jobId);
        }
    }
    async terminateAllSnaps() {
        await Promise.all([...this.jobs.keys()].map((workerId) => this.terminate(workerId)));
        this._snapRpcHooks.clear();
    }
    /**
     * Gets the RPC message handler for the given snap.
     *
     * @param snapId - The id of the Snap whose message handler to get.
     */
    async getRpcMessageHandler(snapId) {
        return this._snapRpcHooks.get(snapId);
    }
    /**
     * Initializes and executes a snap, setting up the communication channels to the snap etc.
     *
     * Depending on the execution environment, this may run forever if the Snap fails to start up properly, therefore any call to this function should be wrapped in a timeout.
     *
     * @param snapData - Data needed for Snap execution.
     */
    async executeSnap(snapData) {
        if (this.snapToJobMap.has(snapData.snapId)) {
            throw new Error(`Snap "${snapData.snapId}" is already being executed.`);
        }
        const job = await this._initJob();
        this._mapSnapAndJob(snapData.snapId, job.id);
        // Ping the worker to ensure that it started up
        await this._command(job.id, {
            jsonrpc: '2.0',
            method: 'ping',
            id: (0, nanoid_1.nanoid)(),
        });
        this.setupSnapProvider(snapData.snapId, job.streams.rpc);
        const result = await this._command(job.id, {
            jsonrpc: '2.0',
            method: 'executeSnap',
            params: snapData,
            id: (0, nanoid_1.nanoid)(),
        });
        this._createSnapHooks(snapData.snapId, job.id);
        return result;
    }
    async _command(jobId, message) {
        if (typeof message !== 'object') {
            throw new Error('Must send object.');
        }
        const job = this.jobs.get(jobId);
        if (!job) {
            throw new Error(`Job with id "${jobId}" not found.`);
        }
        console.log('Parent: Sending Command', message);
        const response = await job.rpcEngine.handle(message);
        if (response.error) {
            throw new Error(response.error.message);
        }
        return response.result;
    }
    _removeSnapHooks(snapId) {
        this._snapRpcHooks.delete(snapId);
    }
    _createSnapHooks(snapId, workerId) {
        const rpcHook = async (origin, request) => {
            return await this._command(workerId, {
                id: (0, nanoid_1.nanoid)(),
                jsonrpc: '2.0',
                method: 'snapRpc',
                params: {
                    origin,
                    request,
                    target: snapId,
                },
            });
        };
        this._snapRpcHooks.set(snapId, rpcHook);
    }
    /**
     * @returns The ID of the snap's job.
     */
    _getJobForSnap(snapId) {
        return this.snapToJobMap.get(snapId);
    }
    /**
     * @returns The ID jobs's snap.
     */
    _getSnapForJob(jobId) {
        return this.jobToSnapMap.get(jobId);
    }
    _mapSnapAndJob(snapId, jobId) {
        this.snapToJobMap.set(snapId, jobId);
        this.jobToSnapMap.set(jobId, snapId);
    }
    _removeSnapAndJobMapping(jobId) {
        const snapId = this.jobToSnapMap.get(jobId);
        if (!snapId) {
            throw new Error(`job: "${jobId}" has no mapped snap.`);
        }
        this.jobToSnapMap.delete(jobId);
        this.snapToJobMap.delete(snapId);
        this._removeSnapHooks(snapId);
    }
}
exports.AbstractExecutionService = AbstractExecutionService;
/**
 * Sets up stream multiplexing for the given stream.
 *
 * @param connectionStream - the stream to mux
 * @param streamName - the name of the stream, for identification in errors
 * @return {stream.Stream} the multiplexed stream
 */
function setupMultiplex(connectionStream, streamName) {
    const mux = new object_multiplex_1.default();
    (0, pump_1.default)(connectionStream, 
    // Typecast: stream type mismatch
    mux, connectionStream, (err) => {
        if (err) {
            streamName
                ? console.error(`"${streamName}" stream failure.`, err)
                : console.error(err);
        }
    });
    return mux;
}
exports.setupMultiplex = setupMultiplex;
//# sourceMappingURL=AbstractExecutionService.js.map