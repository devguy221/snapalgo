"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupMultiplex = exports.AbstractExecutionService = void 0;
const object_multiplex_1 = __importDefault(require("@metamask/object-multiplex"));
const nanoid_1 = require("nanoid");
const pump_1 = __importDefault(require("pump"));
class AbstractExecutionService {
    constructor({ setupSnapProvider, messenger, unresponsivePollingInterval = 5000, unresponsiveTimeout = 30000, }) {
        this._snapRpcHooks = new Map();
        this.jobs = new Map();
        this.setupSnapProvider = setupSnapProvider;
        this.snapToJobMap = new Map();
        this.jobToSnapMap = new Map();
        this._messenger = messenger;
        this._unresponsivePollingInterval = unresponsivePollingInterval;
        this._unresponsiveTimeout = unresponsiveTimeout;
        this._timeoutForUnresponsiveMap = new Map();
    }
    /**
     * Terminates the job with the specified ID and deletes all its associated
     * data. Any subsequent messages targeting the job will fail with an error.
     *
     * @param jobId - The id of the job to be terminated.
     */
    terminate(jobId) {
        const jobWrapper = this.jobs.get(jobId);
        if (!jobWrapper) {
            throw new Error(`Job with id "${jobId}" not found.`);
        }
        Object.values(jobWrapper.streams).forEach((stream) => {
            try {
                !stream.destroyed && stream.destroy();
                stream.removeAllListeners();
            }
            catch (err) {
                console.log('Error while destroying stream', err);
            }
        });
        this._terminate(jobWrapper);
        const snapId = this.jobToSnapMap.get(jobId);
        if (!snapId) {
            throw new Error(`Failed to find a snap for job with id "${jobId}"`);
        }
        clearTimeout(this._timeoutForUnresponsiveMap.get(snapId));
        this._timeoutForUnresponsiveMap.delete(snapId);
        this._removeSnapAndJobMapping(jobId);
        this.jobs.delete(jobId);
        console.log(`job: "${jobId}" terminated`);
    }
    async terminateSnap(snapId) {
        const jobId = this.snapToJobMap.get(snapId);
        if (!jobId) {
            throw new Error(`Job not found for snap with id "${snapId}".`);
        }
        this.terminate(jobId);
    }
    async terminateAllSnaps() {
        for (const workerId of this.jobs.keys()) {
            this.terminate(workerId);
        }
        this._snapRpcHooks.clear();
    }
    /**
     * Gets the RPC message handler for the given snap.
     *
     * @param snapId - The id of the Snap whose message handler to get.
     */
    async getRpcMessageHandler(snapId) {
        return this._snapRpcHooks.get(snapId);
    }
    async executeSnap(snapData) {
        if (this.snapToJobMap.has(snapData.snapId)) {
            throw new Error(`Snap "${snapData.snapId}" is already being executed.`);
        }
        const job = await this._initJob();
        this._mapSnapAndJob(snapData.snapId, job.id);
        this.setupSnapProvider(snapData.snapId, job.streams.rpc);
        const result = await this._command(job.id, {
            jsonrpc: '2.0',
            method: 'executeSnap',
            params: snapData,
            id: nanoid_1.nanoid(),
        });
        // set up poll/ping for status to see if its up, if its not then emit event that it cant be reached
        this._pollForJobStatus(snapData.snapId);
        this._createSnapHooks(snapData.snapId, job.id);
        return result;
    }
    async _command(jobId, message) {
        if (typeof message !== 'object') {
            throw new Error('Must send object.');
        }
        const job = this.jobs.get(jobId);
        if (!job) {
            throw new Error(`Job with id "${jobId}" not found.`);
        }
        console.log('Parent: Sending Command', message);
        const response = await job.rpcEngine.handle(message);
        if (response.error) {
            throw new Error(response.error.message);
        }
        return response.result;
    }
    _removeSnapHooks(snapId) {
        this._snapRpcHooks.delete(snapId);
    }
    _createSnapHooks(snapId, workerId) {
        const rpcHook = async (origin, request) => {
            return await this._command(workerId, {
                id: nanoid_1.nanoid(),
                jsonrpc: '2.0',
                method: 'snapRpc',
                params: {
                    origin,
                    request,
                    target: snapId,
                },
            });
        };
        this._snapRpcHooks.set(snapId, rpcHook);
    }
    _pollForJobStatus(snapId) {
        const jobId = this.snapToJobMap.get(snapId);
        if (!jobId) {
            throw new Error('no job id found for snap');
        }
        const timeout = setTimeout(async () => {
            try {
                await this._getJobStatus(jobId);
                this._pollForJobStatus(snapId);
            }
            catch (_a) {
                // The snap may have been terminated by the time we get here.
                if (this.snapToJobMap.has(snapId)) {
                    this._messenger.publish('ExecutionService:unresponsive', snapId);
                }
            }
        }, this._unresponsivePollingInterval);
        this._timeoutForUnresponsiveMap.set(snapId, timeout);
    }
    async _getJobStatus(jobId) {
        let resolve;
        let reject;
        const timeoutPromise = new Promise((res, rej) => {
            resolve = res;
            reject = rej;
        });
        const timeout = setTimeout(() => {
            reject(new Error('ping request timed out'));
        }, this._unresponsiveTimeout);
        return Promise.race([
            this._command(jobId, {
                jsonrpc: '2.0',
                method: 'ping',
                params: [],
                id: nanoid_1.nanoid(),
            }).then(() => {
                clearTimeout(timeout);
                resolve();
            }),
            timeoutPromise,
        ]);
    }
    /**
     * @returns The ID of the snap's job.
     */
    _getJobForSnap(snapId) {
        return this.snapToJobMap.get(snapId);
    }
    /**
     * @returns The ID jobs's snap.
     */
    _getSnapForJob(jobId) {
        return this.jobToSnapMap.get(jobId);
    }
    _mapSnapAndJob(snapId, jobId) {
        this.snapToJobMap.set(snapId, jobId);
        this.jobToSnapMap.set(jobId, snapId);
    }
    _removeSnapAndJobMapping(jobId) {
        const snapId = this.jobToSnapMap.get(jobId);
        if (!snapId) {
            throw new Error(`job: "${jobId}" has no mapped snap.`);
        }
        this.jobToSnapMap.delete(jobId);
        this.snapToJobMap.delete(snapId);
        this._removeSnapHooks(snapId);
    }
}
exports.AbstractExecutionService = AbstractExecutionService;
/**
 * Sets up stream multiplexing for the given stream.
 *
 * @param connectionStream - the stream to mux
 * @param streamName - the name of the stream, for identification in errors
 * @return {stream.Stream} the multiplexed stream
 */
function setupMultiplex(connectionStream, streamName) {
    const mux = new object_multiplex_1.default();
    pump_1.default(connectionStream, 
    // Typecast: stream type mismatch
    mux, connectionStream, (err) => {
        if (err) {
            streamName
                ? console.error(`"${streamName}" stream failure.`, err)
                : console.error(err);
        }
    });
    return mux;
}
exports.setupMultiplex = setupMultiplex;
//# sourceMappingURL=AbstractExecutionService.js.map