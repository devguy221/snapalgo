"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebWorkerExecutionService = void 0;
const obs_store_1 = require("@metamask/obs-store");
const post_message_stream_1 = require("@metamask/post-message-stream");
const snap_workers_1 = require("@metamask/snap-workers");
const json_rpc_engine_1 = require("json-rpc-engine");
const json_rpc_middleware_stream_1 = require("json-rpc-middleware-stream");
const nanoid_1 = require("nanoid");
const pump_1 = __importDefault(require("pump"));
const AbstractExecutionService_1 = require("./AbstractExecutionService");
class WebWorkerExecutionService extends AbstractExecutionService_1.AbstractExecutionService {
    constructor({ setupSnapProvider, workerUrl, messenger, unresponsivePollingInterval = 5000, unresponsiveTimeout = 30000, }) {
        super({
            setupSnapProvider,
            messenger,
            unresponsivePollingInterval,
            unresponsiveTimeout,
        });
        this.workerUrl = workerUrl;
        this.store = new obs_store_1.ObservableStore({ workers: {} });
    }
    _setWorker(workerId, workerWrapper) {
        this.jobs.set(workerId, workerWrapper);
        const newWorkerState = Object.assign(Object.assign({}, this.store.getState().workers), { [workerId]: workerWrapper });
        this.store.updateState({ workers: newWorkerState });
    }
    _deleteWorker(workerId) {
        this.jobs.delete(workerId);
        const newWorkerState = Object.assign({}, this.store.getState().workers);
        delete newWorkerState[workerId];
        this.store.updateState({ workers: newWorkerState });
    }
    terminate(workerId) {
        const workerWrapper = this.jobs.get(workerId);
        if (!workerWrapper) {
            throw new Error(`Worker with id "${workerId}" not found.`);
        }
        const snapId = this._getSnapForJob(workerId);
        if (!snapId) {
            throw new Error(`Failed to find a snap for worker with id "${workerId}".`);
        }
        Object.values(workerWrapper.streams).forEach((stream) => {
            try {
                !stream.destroyed && stream.destroy();
                stream.removeAllListeners();
            }
            catch (err) {
                console.log('Error while destroying stream', err);
            }
        });
        workerWrapper.worker.terminate();
        this._removeSnapAndJobMapping(workerId);
        this._deleteWorker(workerId);
        clearTimeout(this._timeoutForUnresponsiveMap.get(workerId));
        this._timeoutForUnresponsiveMap.delete(workerId);
        console.log(`worker:${workerId} terminated`);
    }
    async _initJob() {
        const workerId = nanoid_1.nanoid();
        const worker = new Worker(this.workerUrl, {
            name: workerId,
        });
        // Handle out-of-band errors, i.e. errors thrown from the snap outside of the req/res cycle.
        const errorHandler = (ev) => {
            if (this._messenger) {
                const snapId = this.jobToSnapMap.get(workerId);
                if (snapId) {
                    this._messenger.publish('ExecutionService:unhandledError', snapId, {
                        code: ev.error.code,
                        message: ev.error.message,
                        data: ev.error.data,
                    });
                }
            }
        };
        worker.addEventListener('error', errorHandler, { once: true });
        const streams = this._initWorkerStreams(worker, workerId);
        const rpcEngine = new json_rpc_engine_1.JsonRpcEngine();
        const jsonRpcConnection = json_rpc_middleware_stream_1.createStreamMiddleware();
        pump_1.default(jsonRpcConnection.stream, streams.command, jsonRpcConnection.stream);
        rpcEngine.push(jsonRpcConnection.middleware);
        const workerWrapper = {
            id: workerId,
            streams,
            rpcEngine,
            worker,
        };
        this._setWorker(workerId, workerWrapper);
        await this._command(workerId, {
            jsonrpc: '2.0',
            method: 'ping',
            id: nanoid_1.nanoid(),
        });
        return workerWrapper;
    }
    _initWorkerStreams(worker, workerId) {
        const workerStream = new post_message_stream_1.WorkerParentPostMessageStream({ worker });
        // Typecast justification: stream type mismatch
        const mux = AbstractExecutionService_1.setupMultiplex(workerStream, `Worker:${workerId}`);
        const commandStream = mux.createStream(snap_workers_1.SNAP_STREAM_NAMES.COMMAND);
        const rpcStream = mux.createStream(snap_workers_1.SNAP_STREAM_NAMES.JSON_RPC);
        // Typecast: stream type mismatch
        return {
            command: commandStream,
            rpc: rpcStream,
            _connection: workerStream,
        };
    }
}
exports.WebWorkerExecutionService = WebWorkerExecutionService;
//# sourceMappingURL=WebWorkerExecutionService.js.map