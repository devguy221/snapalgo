import { BaseControllerV2 as BaseController, RestrictedControllerMessenger, GetEndowments, GetPermissions, HasPermission, RequestPermissions, RevokeAllPermissions } from '@metamask/controllers';
import { ErrorJSON, ErrorMessageEvent, SnapId, UnresponsiveMessageEvent } from '@metamask/snap-types';
import { SerializedEthereumRpcError } from 'eth-rpc-errors/dist/classes';
import type { Patch } from 'immer';
import { Json } from 'json-rpc-engine';
import { ExecuteSnap, GetRpcMessageHandler, TerminateAll, TerminateSnap } from '../services/ExecutionService';
import { SnapManifest } from './json-schemas';
export declare const controllerName = "SnapController";
export declare const SNAP_PREFIX = "wallet_snap_";
export declare const SNAP_PREFIX_REGEX: RegExp;
export declare const DEFAULT_EXPOSED_APIS: string[];
declare type TruncatedSnapFields = 'id' | 'initialPermissions' | 'permissionName' | 'version';
declare type RequestedSnapPermissions = {
    [permission: string]: Record<string, Json>;
};
/**
 * A Snap as it exists in {@link SnapController} state.
 */
export declare type Snap = {
    /**
     * Whether the Snap is enabled, which determines if it can be started.
     */
    enabled: boolean;
    /**
     * The ID of the Snap.
     */
    id: SnapId;
    /**
     * The initial permissions of the Snap, which will be requested when it is
     * installed.
     */
    initialPermissions: RequestedSnapPermissions;
    /**
     * The Snap's manifest file.
     */
    manifest: SnapManifest;
    /**
     * The name of the permission used to invoke the Snap.
     */
    permissionName: string;
    /**
     * The source code of the Snap.
     */
    sourceCode: string;
    /**
     * The current status of the Snap, e.g. whether it's running or stopped.
     */
    status: SnapStatus;
    /**
     * The version of the Snap.
     */
    version: string;
};
/**
 * A wrapper type for any data stored during runtime of Snaps.
 * It is not persisted in state as it contains non-serializable data and is only relevant for the current session.
 */
export interface SnapRuntimeData {
    /**
     * RPC handler designated for the Snap
     */
    rpcHandler: null | ((origin: string, request: Record<string, unknown>) => Promise<unknown>);
    /**
     * A Unix timestamp for the last time the Snap received an RPC request
     */
    lastRequest: null | number;
    /**
     * A promise that resolves when the Snap has finished installing
     */
    installPromise: null | Promise<Snap>;
}
/**
 * A {@link Snap} object with the fields that are relevant to an external
 * caller.
 */
export declare type TruncatedSnap = Pick<Snap, TruncatedSnapFields>;
export declare type SnapError = {
    message: string;
    code: number;
    data?: Json;
};
export declare type ProcessSnapResult = TruncatedSnap | {
    error: SerializedEthereumRpcError;
};
export declare type InstallSnapsResult = Record<SnapId, ProcessSnapResult>;
declare type CloseAllConnectionsFunction = (origin: string) => void;
declare type StoredSnaps = Record<SnapId, Snap>;
export declare type SnapControllerState = {
    snaps: StoredSnaps;
    snapStates: Record<SnapId, Json>;
    snapErrors: {
        [internalID: string]: SnapError & {
            internalID: string;
        };
    };
};
/**
 * Adds the specified Snap to state. Used during installation.
 */
export declare type AddSnap = {
    type: `${typeof controllerName}:add`;
    handler: SnapController['add'];
};
/**
 * Gets the specified Snap from state.
 */
export declare type GetSnap = {
    type: `${typeof controllerName}:get`;
    handler: SnapController['get'];
};
/**
 * Gets the specified Snap's JSON-RPC message handler function.
 */
export declare type GetSnapRpcMessageHandler = {
    type: `${typeof controllerName}:getRpcMessageHandler`;
    handler: SnapController['getRpcMessageHandler'];
};
/**
 * Gets the specified Snap's persisted state.
 */
export declare type GetSnapState = {
    type: `${typeof controllerName}:getSnapState`;
    handler: SnapController['getSnapState'];
};
/**
 * Checks if the specified snap exists in state.
 */
export declare type HasSnap = {
    type: `${typeof controllerName}:has`;
    handler: SnapController['has'];
};
/**
 * Updates the specified Snap's persisted state.
 */
export declare type UpdateSnapState = {
    type: `${typeof controllerName}:updateSnapState`;
    handler: SnapController['updateSnapState'];
};
export declare type SnapControllerActions = AddSnap | GetSnap | GetSnapRpcMessageHandler | GetSnapState | HasSnap | UpdateSnapState;
export declare type SnapStateChange = {
    type: `${typeof controllerName}:stateChange`;
    payload: [SnapControllerState, Patch[]];
};
/**
 * Emitted when a Snap has been added to state during installation.
 */
export declare type SnapAdded = {
    type: `${typeof controllerName}:snapAdded`;
    payload: [snapId: string, snap: Snap, svgIcon: string | undefined];
};
/**
 * Emitted when a Snap has been started after being added and authorized during
 * installation.
 */
export declare type SnapInstalled = {
    type: `${typeof controllerName}:snapInstalled`;
    payload: [snapId: string];
};
/**
 * Emitted when a Snap is removed.
 */
export declare type SnapRemoved = {
    type: `${typeof controllerName}:snapRemoved`;
    payload: [snapId: string];
};
export declare type SnapControllerEvents = SnapAdded | SnapInstalled | SnapRemoved | SnapStateChange;
export declare type AllowedActions = GetEndowments | GetPermissions | HasPermission | RevokeAllPermissions | RequestPermissions;
export declare type AllowedEvents = ErrorMessageEvent | UnresponsiveMessageEvent;
declare type SnapControllerMessenger = RestrictedControllerMessenger<typeof controllerName, SnapControllerActions | AllowedActions, SnapControllerEvents | AllowedEvents, AllowedActions['type'], AllowedEvents['type']>;
declare type SnapControllerArgs = {
    closeAllConnections: CloseAllConnectionsFunction;
    endowmentPermissionNames: string[];
    executeSnap: ExecuteSnap;
    getRpcMessageHandler: GetRpcMessageHandler;
    messenger: SnapControllerMessenger;
    state?: SnapControllerState;
    terminateAllSnaps: TerminateAll;
    terminateSnap: TerminateSnap;
    idleTimeCheckInterval?: number;
    maxIdleTime?: number;
    maxRequestTime?: number;
    npmRegistryUrl?: string;
};
declare type AddSnapBase = {
    id: SnapId;
    version?: string;
};
declare type AddSnapDirectlyArgs = AddSnapBase & {
    manifest: SnapManifest;
    sourceCode: string;
};
declare type AddSnapArgs = AddSnapBase | AddSnapDirectlyArgs;
export declare enum SnapStatus {
    installing = "installing",
    running = "running",
    stopped = "stopped",
    crashed = "crashed"
}
export declare enum SnapStatusEvent {
    start = "start",
    stop = "stop",
    crash = "crash"
}
export declare class SnapController extends BaseController<string, SnapControllerState, SnapControllerMessenger> {
    private _closeAllConnections;
    private _endowmentPermissionNames;
    private _executeSnap;
    private _getRpcMessageHandler;
    private _idleTimeCheckInterval;
    private _maxIdleTime;
    private _maxRequestTime;
    private _snapsRuntimeData;
    private _terminateAllSnaps;
    private _terminateSnap;
    private _timeoutForLastRequestStatus?;
    private _npmRegistryUrl?;
    constructor({ closeAllConnections, executeSnap, getRpcMessageHandler, messenger, state, terminateAllSnaps, terminateSnap, endowmentPermissionNames, npmRegistryUrl, idleTimeCheckInterval, maxIdleTime, maxRequestTime, }: SnapControllerArgs);
    /**
     * Constructor helper for registering the controller's messaging system
     * actions.
     */
    private registerMessageHandlers;
    _pollForLastRequestStatus(): void;
    _stopSnapsLastRequestPastMax(): void;
    _onUnresponsiveSnap(snapId: SnapId): void;
    _onUnhandledSnapError(snapId: SnapId, error: ErrorJSON): void;
    /**
     * Transitions between states using `snapStatusStateMachineConfig` as the template to figure out the next state.
     * This transition function uses a very minimal subset of XState conventions:
     * - supports initial state
     * - .on supports raw event target string
     * - .on supports {target, cond} object
     * - the arguments for `cond` is the `SerializedSnap` instead of Xstate convention of `(event, context) => boolean`
     *
     * @param snapId - The id of the snap to transition
     * @param event - The event enum to use to transition
     */
    _transitionSnapState(snapId: SnapId, event: SnapStatusEvent): void;
    /**
     * Starts the given snap. Throws an error if no such snap exists
     * or if it is already running.
     *
     * @param snapId - The id of the Snap to start.
     */
    startSnap(snapId: SnapId): Promise<void>;
    /**
     * Enables the given snap. A snap can only be started if it is enabled.
     *
     * @param snapId - The id of the Snap to enable.
     */
    enableSnap(snapId: SnapId): void;
    /**
     * Disables the given snap. A snap can only be started if it is enabled.
     *
     * @param snapId - The id of the Snap to disable.
     */
    disableSnap(snapId: SnapId): Promise<void>;
    /**
     * Stops the given snap. Throws an error if no such snap exists
     * or if it is already stopped.
     *
     * @param snapId - The id of the Snap to stop.
     */
    stopSnap(snapId: SnapId): Promise<void>;
    /**
     * Stops the given snap, removes all hooks, closes all connections, and
     * terminates its worker.
     *
     * @param snapId - The id of the Snap to stop.
     * @param setNotRunning - Whether to mark the snap as not running. Should
     * only be set to `false` if the state is properly transitioned by the caller.
     */
    private _stopSnap;
    /**
     * Returns whether the given snap is running.
     * Throws an error if the snap doesn't exist.
     *
     * @param snapId - The id of the Snap to check.
     */
    isRunning(snapId: SnapId): boolean;
    /**
     * Returns whether the given snap has been added to state.
     *
     * @param snapId - The id of the Snap to check for.
     */
    has(snapId: SnapId): boolean;
    /**
     * Gets the snap with the given id if it exists, including all data.
     * This should not be used if the snap is to be serializable, as e.g.
     * the snap sourceCode may be quite large.
     *
     * @param snapId - The id of the Snap to get.
     */
    get(snapId: SnapId): Snap;
    /**
     * Gets the snap with the given id if it exists, excluding any
     * non-serializable or expensive-to-serialize data.
     *
     * @param snapId - The id of the Snap to get.
     */
    getTruncated(snapId: SnapId): TruncatedSnap | null;
    /**
     * Updates the own state of the snap with the given id.
     * This is distinct from the state MetaMask uses to manage snaps.
     *
     * @param snapId - The id of the Snap whose state should be updated.
     * @param newSnapState - The new state of the snap.
     */
    updateSnapState(snapId: SnapId, newSnapState: Json): Promise<void>;
    /**
     * Adds error from a snap to the SnapControllers state.
     *
     * @param snapError - The error to store on the SnapController
     */
    addSnapError(snapError: SnapError): Promise<void>;
    /**
     * Removes an error by internalID from a the SnapControllers state.
     *
     * @param internalID - The internal error ID to remove on the SnapController
     */
    removeSnapError(internalID: string): Promise<void>;
    /**
     * Clears all errors from the SnapControllers state.
     *
     */
    clearSnapErrors(): Promise<void>;
    /**
     * Gets the own state of the snap with the given id.
     * This is distinct from the state MetaMask uses to manage snaps.
     *
     * @param snapId - The id of the Snap whose state to get.
     */
    getSnapState(snapId: SnapId): Promise<Json>;
    /**
     * Completely clear the controller's state: delete all associated data,
     * handlers, event listeners, and permissions; tear down all snap providers.
     */
    clearState(): void;
    /**
     * Removes the given snap from state, and clears all associated handlers
     * and listeners.
     *
     * @param snapId - The id of the Snap.
     */
    removeSnap(snapId: SnapId): Promise<void>;
    /**
     * Stops the given snaps, removes them from state, and clears all associated
     * permissions, handlers, and listeners.
     *
     * @param snapIds - The ids of the Snaps.
     */
    removeSnaps(snapIds: string[]): Promise<void>;
    /**
     * Gets the serialized permitted snaps of the given origin, if any.
     * @param origin - The origin whose permitted snaps to retrieve.
     */
    getPermittedSnaps(origin: string): InstallSnapsResult;
    /**
     * Installs the snaps requested by the given origin, returning the snap
     * object if the origin is permitted to install it, and an authorization error
     * otherwise.
     *
     * @param origin - The origin that requested to install the snaps.
     * @param requestedSnaps - The snaps to install.
     * @returns An object of snap ids and snap objects, or errors if a
     * snap couldn't be installed.
     */
    installSnaps(origin: string, requestedSnaps: RequestedSnapPermissions): Promise<InstallSnapsResult>;
    /**
     * Adds, authorizes, and runs the given snap with a snap provider.
     * Results from this method should be efficiently serializable.
     *
     * @param snapId - The id of the snap.
     * @param version - The version of the snap to install.
     * @returns The resulting snap object, or an error if something went wrong.
     */
    private processRequestedSnap;
    /**
     * Returns a promise representing the complete installation of the requested snap.
     * If the snap is already being installed, the previously pending promise will be returned.
     *
     * @param snapId - The id of the Snap.
     * @param args - Object containing either the URL of the snap's manifest,
     * or the snap's manifest and source code.
     * @returns The resulting snap object.
     */
    add(args: AddSnapArgs): Promise<Snap>;
    private validateSnapId;
    private _startSnap;
    /**
     * Gets the names of all endowments that will be added to the Snap's
     * Compartment when it executes. These should be the names of global
     * JavaScript APIs accessible in the root realm of the execution environment.
     *
     * Throws an error if the endowment getter for a permission returns a truthy
     * value that is not an array of strings.
     *
     * @param snapId - The id of the snap whose SES endowments to get.
     * @returns An array of the names of the endowments.
     */
    private _getEndowments;
    /**
     * Internal method. See the "add" method.
     *
     * @param snapId - The id of the Snap.
     * @param args - The add snap args.
     * @returns The resulting snap object.
     */
    private _add;
    /**
     * Fetches the manifest and source code of a snap.
     *
     * @param snapId - The id of the Snap.
     * @param version - The version of the Snap to fetch.
     * @returns A tuple of the Snap manifest object and the Snap source code.
     */
    private _fetchSnap;
    private _fetchNpmSnap;
    /**
     * Fetches the manifest and source code of a local snap.
     *
     * @param localhostUrl - The localhost URL to download from.
     * @returns The validated manifest and the source code.
     */
    private _fetchLocalSnap;
    /**
     * Initiates a request for the given snap's initial permissions.
     * Must be called in order. See processRequestedSnap.
     *
     * @param snapId - The id of the Snap.
     * @returns The snap's approvedPermissions.
     */
    private authorize;
    destroy(): void;
    /**
     * Gets the RPC message handler for the given snap.
     *
     * @param snapId - The id of the Snap whose message handler to get.
     */
    getRpcMessageHandler(snapId: SnapId): Promise<(origin: string, request: Record<string, unknown>) => Promise<unknown>>;
    private _recordSnapRpcRequest;
    private _getSnapRuntimeData;
}
export {};
