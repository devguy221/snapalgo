import { AddApprovalRequest, BaseControllerV2 as BaseController, GetEndowments, GetPermissions, GrantPermissions, HasPermission, HasPermissions, RequestPermissions, RestrictedControllerMessenger, RevokeAllPermissions, RevokePermissionForAllSubjects, RevokePermissions } from '@metamask/controllers';
import { ErrorJSON, ErrorMessageEvent, SnapId } from '@metamask/snap-types';
import { SerializedEthereumRpcError } from 'eth-rpc-errors/dist/classes';
import type { Patch } from 'immer';
import { Json } from 'json-rpc-engine';
import { ExecuteSnap, GetRpcMessageHandler, TerminateAll, TerminateSnap } from '../services/ExecutionService';
import { SnapManifest } from './json-schemas';
import { ValidatedSnapId } from './utils';
export declare const controllerName = "SnapController";
export declare const SNAP_PREFIX_REGEX: RegExp;
export declare const SNAP_APPROVAL_UPDATE = "wallet_updateSnap";
declare type TruncatedSnapFields = 'id' | 'initialPermissions' | 'permissionName' | 'version';
declare type RequestedSnapPermissions = {
    [permission: string]: Record<string, Json>;
};
/**
 * A Snap as it exists in {@link SnapController} state.
 */
export declare type Snap = {
    /**
     * Whether the Snap is enabled, which determines if it can be started.
     */
    enabled: boolean;
    /**
     * The ID of the Snap.
     */
    id: SnapId;
    /**
     * The initial permissions of the Snap, which will be requested when it is
     * installed.
     */
    initialPermissions: RequestedSnapPermissions;
    /**
     * The Snap's manifest file.
     */
    manifest: SnapManifest;
    /**
     * The name of the permission used to invoke the Snap.
     */
    permissionName: string;
    /**
     * The source code of the Snap.
     */
    sourceCode: string;
    /**
     * The current status of the Snap, e.g. whether it's running or stopped.
     */
    status: SnapStatus;
    /**
     * The version of the Snap.
     */
    version: string;
    /**
     * The version history of the Snap.
     * Can be used to derive when the Snap was installed, when it was updated to a certain version and who requested the change.
     */
    versionHistory: VersionHistory[];
};
export declare type VersionHistory = {
    origin: string;
    version: string;
    date: number;
};
/**
 * A wrapper type for any data stored during runtime of Snaps.
 * It is not persisted in state as it contains non-serializable data and is only relevant for the current session.
 */
export interface SnapRuntimeData {
    /**
     * A promise that resolves when the Snap has finished installing
     */
    installPromise: null | Promise<Snap>;
    /**
     * A Unix timestamp for the last time the Snap received an RPC request
     */
    lastRequest: null | number;
    /**
     * The current number of pending requests
     */
    pendingRequests: number;
    /**
     * RPC handler designated for the Snap
     */
    rpcHandler: null | ((origin: string, request: Record<string, unknown>) => Promise<unknown>);
}
/**
 * A {@link Snap} object with the fields that are relevant to an external
 * caller.
 */
export declare type TruncatedSnap = Pick<Snap, TruncatedSnapFields>;
export declare type SnapError = {
    message: string;
    code: number;
    data?: Json;
};
export declare type ProcessSnapResult = TruncatedSnap | {
    error: SerializedEthereumRpcError;
};
export declare type InstallSnapsResult = Record<SnapId, ProcessSnapResult>;
declare type CloseAllConnectionsFunction = (origin: string) => void;
declare type StoredSnaps = Record<SnapId, Snap>;
export declare type SnapControllerState = {
    snaps: StoredSnaps;
    snapStates: Record<SnapId, Json>;
    snapErrors: {
        [internalID: string]: SnapError & {
            internalID: string;
        };
    };
};
/**
 * Adds the specified Snap to state. Used during installation.
 */
export declare type AddSnap = {
    type: `${typeof controllerName}:add`;
    handler: SnapController['add'];
};
/**
 * Gets the specified Snap from state.
 */
export declare type GetSnap = {
    type: `${typeof controllerName}:get`;
    handler: SnapController['get'];
};
/**
 * Gets the specified Snap's JSON-RPC message handler function.
 */
export declare type GetSnapRpcMessageHandler = {
    type: `${typeof controllerName}:getRpcMessageHandler`;
    handler: SnapController['getRpcMessageHandler'];
};
/**
 * Gets the specified Snap's persisted state.
 */
export declare type GetSnapState = {
    type: `${typeof controllerName}:getSnapState`;
    handler: SnapController['getSnapState'];
};
/**
 * Checks if the specified snap exists in state.
 */
export declare type HasSnap = {
    type: `${typeof controllerName}:has`;
    handler: SnapController['has'];
};
/**
 * Updates the specified Snap's persisted state.
 */
export declare type UpdateSnapState = {
    type: `${typeof controllerName}:updateSnapState`;
    handler: SnapController['updateSnapState'];
};
/**
 * Clears the specified Snap's persisted state.
 */
export declare type ClearSnapState = {
    type: `${typeof controllerName}:clearSnapState`;
    handler: SnapController['clearSnapState'];
};
export declare type SnapControllerActions = AddSnap | GetSnap | GetSnapRpcMessageHandler | GetSnapState | HasSnap | UpdateSnapState | ClearSnapState;
export declare type SnapStateChange = {
    type: `${typeof controllerName}:stateChange`;
    payload: [SnapControllerState, Patch[]];
};
/**
 * Emitted when a Snap has been added to state during installation.
 */
export declare type SnapAdded = {
    type: `${typeof controllerName}:snapAdded`;
    payload: [snapId: string, snap: Snap, svgIcon: string | undefined];
};
/**
 * Emitted when a Snap has been started after being added and authorized during
 * installation.
 */
export declare type SnapInstalled = {
    type: `${typeof controllerName}:snapInstalled`;
    payload: [snapId: string];
};
/**
 * Emitted when a Snap is removed.
 */
export declare type SnapRemoved = {
    type: `${typeof controllerName}:snapRemoved`;
    payload: [snapId: string];
};
/**
 * Emitted when a Snap is updated
 */
export declare type SnapUpdated = {
    type: `${typeof controllerName}:snapUpdated`;
    payload: [snapId: string, newVersion: string, oldVersion: string];
};
/**
 * Emitted when a Snap is terminated. This is different from the snap being
 * stopped as it can also be triggered when a snap fails initialization.
 */
export declare type SnapTerminated = {
    type: `${typeof controllerName}:snapTerminated`;
    payload: [snapId: string];
};
export declare type SnapControllerEvents = SnapAdded | SnapInstalled | SnapRemoved | SnapStateChange | SnapUpdated | SnapTerminated;
export declare type AllowedActions = GetEndowments | GetPermissions | HasPermission | HasPermissions | RevokePermissions | RequestPermissions | RevokeAllPermissions | RevokePermissionForAllSubjects | GrantPermissions | RequestPermissions | AddApprovalRequest;
export declare type AllowedEvents = ErrorMessageEvent;
declare type SnapControllerMessenger = RestrictedControllerMessenger<typeof controllerName, SnapControllerActions | AllowedActions, SnapControllerEvents | AllowedEvents, AllowedActions['type'], AllowedEvents['type']>;
declare type FeatureFlags = {
    /**
     * We still need to implement new UI approval page in metamask-extension before we can allow DApps to update Snaps.
     * After it's added, this flag can be removed.
     * @see {SNAP_APPROVAL_UPDATE}
     * @see {SnapController.processRequestedSnap}
     */
    dappsCanUpdateSnaps?: true;
};
declare type SnapControllerArgs = {
    /**
     * A teardown function that allows the host to clean up its instrumentation
     * for a running snap.
     */
    closeAllConnections: CloseAllConnectionsFunction;
    /**
     * The names of endowment permissions whose values are the names of JavaScript
     * APIs that will be added to the snap execution environment at runtime.
     */
    environmentEndowmentPermissions: string[];
    /**
     * A function that causes a snap to be executed.
     */
    executeSnap: ExecuteSnap;
    /**
     * A function that gets the RPC message handler function for a specific
     * snap.
     */
    getRpcMessageHandler: GetRpcMessageHandler;
    /**
     * The controller messenger.
     */
    messenger: SnapControllerMessenger;
    /**
     * Persisted state that will be used for rehydration.
     */
    state?: SnapControllerState;
    /**
     * A function that terminates all running snaps.
     */
    terminateAllSnaps: TerminateAll;
    /**
     * A function that terminates a specific snap.
     */
    terminateSnap: TerminateSnap;
    /**
     * How frequently to check whether a snap is idle.
     */
    idleTimeCheckInterval?: number;
    /**
     * The maximum amount of time that a snap may be idle.
     */
    maxIdleTime?: number;
    /**
     * The maximum amount of time a snap may take to process an RPC request,
     * unless it is permitted to take longer.
     */
    maxRequestTime?: number;
    /**
     * The npm registry URL that will be used to fetch published snaps.
     */
    npmRegistryUrl?: string;
    /**
     * The function that will be used by the controller fo make network requests.
     * Should be compatible with {@link fetch}.
     */
    fetchFunction?: typeof fetch;
    /**
     * Flags that enable or disable features in the controller.
     * See {@link FeatureFlags}.
     */
    featureFlags: FeatureFlags;
};
declare type AddSnapBase = {
    id: SnapId;
    origin: string;
    versionRange?: string;
};
declare type AddSnapDirectlyArgs = AddSnapBase & {
    manifest: SnapManifest;
    sourceCode: string;
};
declare type AddSnapArgs = AddSnapBase | AddSnapDirectlyArgs;
export declare enum SnapStatus {
    installing = "installing",
    running = "running",
    stopped = "stopped",
    crashed = "crashed"
}
export declare enum SnapStatusEvent {
    start = "start",
    stop = "stop",
    crash = "crash",
    update = "update"
}
export declare class SnapController extends BaseController<string, SnapControllerState, SnapControllerMessenger> {
    private _closeAllConnections;
    private _environmentEndowmentPermissions;
    private _executeSnap;
    private _getRpcMessageHandler;
    private _idleTimeCheckInterval;
    private _maxIdleTime;
    private _maxRequestTime;
    private _snapsRuntimeData;
    private _terminateAllSnaps;
    private _terminateSnap;
    private _timeoutForLastRequestStatus?;
    private _npmRegistryUrl?;
    private _fetchFunction;
    private _featureFlags;
    constructor({ closeAllConnections, executeSnap, getRpcMessageHandler, messenger, state, terminateAllSnaps, terminateSnap, environmentEndowmentPermissions, npmRegistryUrl, idleTimeCheckInterval, maxIdleTime, maxRequestTime, fetchFunction, featureFlags, }: SnapControllerArgs);
    /**
     * Constructor helper for registering the controller's messaging system
     * actions.
     */
    private registerMessageHandlers;
    _pollForLastRequestStatus(): void;
    _stopSnapsLastRequestPastMax(): Promise<void[]>;
    _onUnhandledSnapError(snapId: SnapId, error: ErrorJSON): Promise<void>;
    /**
     * Transitions between states using `snapStatusStateMachineConfig` as the template to figure out the next state.
     * This transition function uses a very minimal subset of XState conventions:
     * - supports initial state
     * - .on supports raw event target string
     * - .on supports {target, cond} object
     * - the arguments for `cond` is the `SerializedSnap` instead of Xstate convention of `(event, context) => boolean`
     *
     * @param snapId - The id of the snap to transition
     * @param event - The event enum to use to transition
     */
    _transitionSnapState(snapId: SnapId, event: SnapStatusEvent): void;
    /**
     * Starts the given snap. Throws an error if no such snap exists
     * or if it is already running.
     *
     * @param snapId - The id of the Snap to start.
     */
    startSnap(snapId: SnapId): Promise<void>;
    /**
     * Enables the given snap. A snap can only be started if it is enabled.
     *
     * @param snapId - The id of the Snap to enable.
     */
    enableSnap(snapId: SnapId): void;
    /**
     * Disables the given snap. A snap can only be started if it is enabled.
     *
     * @param snapId - The id of the Snap to disable.
     */
    disableSnap(snapId: SnapId): Promise<void>;
    /**
     * Stops the given snap, removes all hooks, closes all connections, and
     * terminates its worker.
     *
     * @param snapId - The id of the Snap to stop.
     * @param statusEvent - The Snap status event that caused the snap to be
     * stopped.
     */
    stopSnap(snapId: SnapId, statusEvent?: SnapStatusEvent.stop | SnapStatusEvent.crash): Promise<void>;
    /**
     * Terminates the specified snap and emits the `snapTerminated` event.
     *
     * @param snapId - The snap to terminate.
     */
    private terminateSnap;
    /**
     * Returns whether the given snap is running.
     * Throws an error if the snap doesn't exist.
     *
     * @param snapId - The id of the Snap to check.
     */
    isRunning(snapId: SnapId): boolean;
    /**
     * Returns whether the given snap has been added to state.
     *
     * @param snapId - The id of the Snap to check for.
     */
    has(snapId: SnapId): boolean;
    /**
     * Gets the snap with the given id if it exists, including all data.
     * This should not be used if the snap is to be serializable, as e.g.
     * the snap sourceCode may be quite large.
     *
     * @param snapId - The id of the Snap to get.
     */
    get(snapId: SnapId): Snap | undefined;
    /**
     * Gets the snap with the given id if it exists, excluding any
     * non-serializable or expensive-to-serialize data.
     *
     * @param snapId - The id of the Snap to get.
     */
    getTruncated(snapId: SnapId): TruncatedSnap | null;
    /**
     * Updates the own state of the snap with the given id.
     * This is distinct from the state MetaMask uses to manage snaps.
     *
     * @param snapId - The id of the Snap whose state should be updated.
     * @param newSnapState - The new state of the snap.
     */
    updateSnapState(snapId: SnapId, newSnapState: Json): Promise<void>;
    /**
     * Clears the state of the snap with the given id.
     * This is distinct from the state MetaMask uses to manage snaps.
     *
     * @param snapId - The id of the Snap whose state should be cleared.
     */
    clearSnapState(snapId: SnapId): Promise<void>;
    /**
     * Adds error from a snap to the SnapControllers state.
     *
     * @param snapError - The error to store on the SnapController
     */
    addSnapError(snapError: SnapError): void;
    /**
     * Removes an error by internalID from a the SnapControllers state.
     *
     * @param internalID - The internal error ID to remove on the SnapController
     */
    removeSnapError(internalID: string): Promise<void>;
    /**
     * Clears all errors from the SnapControllers state.
     *
     */
    clearSnapErrors(): Promise<void>;
    /**
     * Gets the own state of the snap with the given id.
     * This is distinct from the state MetaMask uses to manage snaps.
     *
     * @param snapId - The id of the Snap whose state to get.
     */
    getSnapState(snapId: SnapId): Promise<Json>;
    /**
     * Completely clear the controller's state: delete all associated data,
     * handlers, event listeners, and permissions; tear down all snap providers.
     */
    clearState(): void;
    /**
     * Removes the given snap from state, and clears all associated handlers
     * and listeners.
     *
     * @param snapId - The id of the Snap.
     */
    removeSnap(snapId: SnapId): Promise<void>;
    /**
     * Stops the given snaps, removes them from state, and clears all associated
     * permissions, handlers, and listeners.
     *
     * @param snapIds - The ids of the Snaps.
     */
    removeSnaps(snapIds: string[]): Promise<void>;
    /**
     * Safely revokes all permissions granted to a Snap.
     *
     * @param snapId - The snap ID.
     */
    private revokeAllSnapPermissions;
    /**
     * Gets the serialized permitted snaps of the given origin, if any.
     * @param origin - The origin whose permitted snaps to retrieve.
     */
    getPermittedSnaps(origin: string): InstallSnapsResult;
    /**
     * Installs the snaps requested by the given origin, returning the snap
     * object if the origin is permitted to install it, and an authorization error
     * otherwise.
     *
     * @param origin - The origin that requested to install the snaps.
     * @param requestedSnaps - The snaps to install.
     * @returns An object of snap ids and snap objects, or errors if a
     * snap couldn't be installed.
     */
    installSnaps(origin: string, requestedSnaps: RequestedSnapPermissions): Promise<InstallSnapsResult>;
    /**
     * Adds, authorizes, and runs the given snap with a snap provider.
     * Results from this method should be efficiently serializable.
     *
     * @param origin - The origin requesting the snap.
     * @param _snapId - The id of the snap.
     * @param versionRange - The semver range of the snap to install.
     * @returns The resulting snap object, or an error if something went wrong.
     */
    private processRequestedSnap;
    /**
     * Ask a user for approval, updates, re-authorizes and then restarts given snap.
     *
     * @param snapId The id of the Snap to be updated
     * @param newVersionRange A semver version range in which the maximum version will be chosen
     * @returns @type {TruncatedSnap} if updated, @type {null} otherwise
     */
    updateSnap(origin: string, snapId: ValidatedSnapId, newVersionRange?: string): Promise<TruncatedSnap | null>;
    /**
     * Returns a promise representing the complete installation of the requested snap.
     * If the snap is already being installed, the previously pending promise will be returned.
     *
     * @param snapId - The id of the Snap.
     * @param args - Object containing either the URL of the snap's manifest,
     * or the snap's manifest and source code.
     * @returns The resulting snap object.
     */
    add(args: AddSnapArgs): Promise<Snap>;
    private validateSnapId;
    private _startSnap;
    /**
     * Gets the names of all endowments that will be added to the Snap's
     * Compartment when it executes. These should be the names of global
     * JavaScript APIs accessible in the root realm of the execution environment.
     *
     * Throws an error if the endowment getter for a permission returns a truthy
     * value that is not an array of strings.
     *
     * @param snapId - The id of the snap whose SES endowments to get.
     * @returns An array of the names of the endowments.
     */
    private _getEndowments;
    /**
     * Internal method. See the "add" method.
     *
     * @param args - The add snap args.
     * @returns The resulting snap object.
     */
    private _set;
    /**
     * Fetches the manifest and source code of a snap.
     *
     * @param snapId - The id of the Snap.
     * @param versionRange - The SemVer version of the Snap to fetch.
     * @returns A tuple of the Snap manifest object and the Snap source code.
     */
    private _fetchSnap;
    private _fetchNpmSnap;
    /**
     * Fetches the manifest and source code of a local snap.
     *
     * @param localhostUrl - The localhost URL to download from.
     * @returns The validated manifest and the source code.
     */
    private _fetchLocalSnap;
    /**
     * Initiates a request for the given snap's initial permissions.
     * Must be called in order. See processRequestedSnap.
     *
     * @param snapId - The id of the Snap.
     * @returns The snap's approvedPermissions.
     */
    private authorize;
    destroy(): void;
    /**
     * Gets the RPC message handler for the given snap.
     *
     * @param snapId - The id of the Snap whose message handler to get.
     */
    getRpcMessageHandler(snapId: SnapId): Promise<(origin: string, request: Record<string, unknown>) => Promise<unknown>>;
    /**
     * Awaits the specified promise and rejects if the promise doesn't resolve
     * before the timeout.
     *
     * @param snapId - The snap id.
     * @param promise - The promise to await.
     * @returns The result of the promise or rejects if the promise times out.
     */
    private _executeWithTimeout;
    private _recordSnapRpcRequestStart;
    private _recordSnapRpcRequestFinish;
    private _getSnapRuntimeData;
    private calculatePermissionsChange;
}
export {};
