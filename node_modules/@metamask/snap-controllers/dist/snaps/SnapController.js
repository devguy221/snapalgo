"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnapController = exports.SnapStatusEvent = exports.SnapStatus = exports.SNAP_APPROVAL_UPDATE = exports.SNAP_PREFIX_REGEX = exports.controllerName = void 0;
const controllers_1 = require("@metamask/controllers");
const utils_1 = require("@metamask/utils");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const nanoid_1 = require("nanoid");
const semver_1 = require("semver");
const __1 = require("..");
const utils_2 = require("../utils");
const default_endowments_1 = require("./default-endowments");
const json_schemas_1 = require("./json-schemas");
const endowments_1 = require("./endowments");
const RequestQueue_1 = require("./RequestQueue");
const utils_3 = require("./utils");
exports.controllerName = 'SnapController';
exports.SNAP_PREFIX_REGEX = new RegExp(`^${utils_3.SNAP_PREFIX}`, 'u');
exports.SNAP_APPROVAL_UPDATE = 'wallet_updateSnap';
const TRUNCATED_SNAP_PROPERTIES = new Set([
    'initialPermissions',
    'id',
    'permissionName',
    'version',
]);
const defaultState = {
    snapErrors: {},
    snaps: {},
    snapStates: {},
};
var SnapStatus;
(function (SnapStatus) {
    SnapStatus["installing"] = "installing";
    SnapStatus["running"] = "running";
    SnapStatus["stopped"] = "stopped";
    SnapStatus["crashed"] = "crashed";
})(SnapStatus = exports.SnapStatus || (exports.SnapStatus = {}));
var SnapStatusEvent;
(function (SnapStatusEvent) {
    SnapStatusEvent["start"] = "start";
    SnapStatusEvent["stop"] = "stop";
    SnapStatusEvent["crash"] = "crash";
    SnapStatusEvent["update"] = "update";
})(SnapStatusEvent = exports.SnapStatusEvent || (exports.SnapStatusEvent = {}));
/**
 * Guard transitioning when the snap is disabled.
 */
const disabledGuard = (serializedSnap) => {
    return serializedSnap.enabled;
};
/**
 * The state machine configuration for a snaps `status` state.
 * Using a state machine for a snaps `status` ensures that the snap transitions to a valid next lifecycle state.
 * Supports a very minimal subset of XState conventions outlined in `_transitionSnapState`.
 */
const snapStatusStateMachineConfig = {
    initial: SnapStatus.installing,
    states: {
        [SnapStatus.installing]: {
            on: {
                [SnapStatusEvent.start]: {
                    target: SnapStatus.running,
                    cond: disabledGuard,
                },
            },
        },
        [SnapStatus.running]: {
            on: {
                [SnapStatusEvent.stop]: SnapStatus.stopped,
                [SnapStatusEvent.crash]: SnapStatus.crashed,
            },
        },
        [SnapStatus.stopped]: {
            on: {
                [SnapStatusEvent.start]: {
                    target: SnapStatus.running,
                    cond: disabledGuard,
                },
                [SnapStatusEvent.update]: SnapStatus.installing,
            },
        },
        [SnapStatus.crashed]: {
            on: {
                [SnapStatusEvent.start]: {
                    target: SnapStatus.running,
                    cond: disabledGuard,
                },
            },
        },
    },
};
const name = 'SnapController';
/*
 * A snap is initialized in three phases:
 * - Add: Loads the snap from a remote source and parses it.
 * - Authorize: Requests the snap's required permissions from the user.
 * - Start: Initializes the snap in its SES realm with the authorized permissions.
 */
class SnapController extends controllers_1.BaseControllerV2 {
    constructor({ closeAllConnections, executeSnap, getRpcMessageHandler, messenger, state, terminateAllSnaps, terminateSnap, environmentEndowmentPermissions = [], npmRegistryUrl, idleTimeCheckInterval = (0, utils_1.inMilliseconds)(5, utils_1.Duration.Second), maxIdleTime = (0, utils_1.inMilliseconds)(30, utils_1.Duration.Second), maxRequestTime = (0, utils_1.inMilliseconds)(60, utils_1.Duration.Second), fetchFunction = globalThis.fetch.bind(globalThis), featureFlags = {}, }) {
        super({
            messenger,
            metadata: {
                snapErrors: {
                    persist: false,
                    anonymous: false,
                },
                snapStates: {
                    persist: true,
                    anonymous: false,
                },
                snaps: {
                    persist: (snaps) => {
                        return Object.values(snaps)
                            .map((snap) => {
                            return {
                                ...snap,
                                // At the time state is rehydrated, no snap will be running.
                                status: SnapStatus.stopped,
                            };
                        })
                            .reduce((memo, snap) => {
                            memo[snap.id] = snap;
                            return memo;
                        }, {});
                    },
                    anonymous: false,
                },
            },
            name,
            state: { ...defaultState, ...state },
        });
        this._closeAllConnections = closeAllConnections;
        this._environmentEndowmentPermissions = environmentEndowmentPermissions;
        this._executeSnap = executeSnap;
        this._getRpcMessageHandler = getRpcMessageHandler;
        this._onUnhandledSnapError = this._onUnhandledSnapError.bind(this);
        this._terminateSnap = terminateSnap;
        this._terminateAllSnaps = terminateAllSnaps;
        this._idleTimeCheckInterval = idleTimeCheckInterval;
        this._maxIdleTime = maxIdleTime;
        this._maxRequestTime = maxRequestTime;
        this._pollForLastRequestStatus();
        this._snapsRuntimeData = new Map();
        this._npmRegistryUrl = npmRegistryUrl;
        this._fetchFunction = fetchFunction;
        this._featureFlags = featureFlags;
        this.messagingSystem.subscribe('ExecutionService:unhandledError', this._onUnhandledSnapError);
        this.registerMessageHandlers();
    }
    /**
     * Constructor helper for registering the controller's messaging system
     * actions.
     */
    registerMessageHandlers() {
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:add`, (...args) => this.add(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:get`, (...args) => this.get(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:getRpcMessageHandler`, (...args) => this.getRpcMessageHandler(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:getSnapState`, (...args) => this.getSnapState(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:has`, (...args) => this.has(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:updateSnapState`, (...args) => this.updateSnapState(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:clearSnapState`, (...args) => this.clearSnapState(...args));
    }
    _pollForLastRequestStatus() {
        this._timeoutForLastRequestStatus = setTimeout(async () => {
            await this._stopSnapsLastRequestPastMax();
            this._pollForLastRequestStatus();
        }, this._idleTimeCheckInterval);
    }
    async _stopSnapsLastRequestPastMax() {
        const entries = [...this._snapsRuntimeData.entries()];
        return Promise.all(entries
            .filter(([_snapId, runtime]) => runtime.pendingRequests === 0 &&
            // lastRequest should always be set here but TypeScript wants this check
            runtime.lastRequest &&
            this._maxIdleTime &&
            (0, utils_1.timeSince)(runtime.lastRequest) > this._maxIdleTime)
            .map(([snapId]) => this.stopSnap(snapId, SnapStatusEvent.stop)));
    }
    async _onUnhandledSnapError(snapId, error) {
        await this.stopSnap(snapId, SnapStatusEvent.crash);
        this.addSnapError(error);
    }
    /**
     * Transitions between states using `snapStatusStateMachineConfig` as the template to figure out the next state.
     * This transition function uses a very minimal subset of XState conventions:
     * - supports initial state
     * - .on supports raw event target string
     * - .on supports {target, cond} object
     * - the arguments for `cond` is the `SerializedSnap` instead of Xstate convention of `(event, context) => boolean`
     *
     * @param snapId - The id of the snap to transition
     * @param event - The event enum to use to transition
     */
    _transitionSnapState(snapId, event) {
        const snapStatus = this.state.snaps[snapId].status;
        let nextStatus = snapStatusStateMachineConfig.states[snapStatus].on[event] ??
            snapStatus;
        if (nextStatus.cond) {
            const cond = nextStatus.cond(this.state.snaps[snapId]);
            if (cond === false) {
                throw new Error(`Condition failed for state transition "${snapId}" with event "${event}".`);
            }
        }
        if (nextStatus.target) {
            nextStatus = nextStatus.target;
        }
        if (nextStatus === snapStatus) {
            return;
        }
        this.update((state) => {
            state.snaps[snapId].status = nextStatus;
        });
    }
    /**
     * Starts the given snap. Throws an error if no such snap exists
     * or if it is already running.
     *
     * @param snapId - The id of the Snap to start.
     */
    async startSnap(snapId) {
        const snap = this.get(snapId);
        if (!snap) {
            throw new Error(`Snap "${snapId}" not found.`);
        }
        if (this.state.snaps[snapId].enabled === false) {
            throw new Error(`Snap "${snapId}" is disabled.`);
        }
        await this._startSnap({
            snapId,
            sourceCode: snap.sourceCode,
        });
    }
    /**
     * Enables the given snap. A snap can only be started if it is enabled.
     *
     * @param snapId - The id of the Snap to enable.
     */
    enableSnap(snapId) {
        this.update((state) => {
            state.snaps[snapId].enabled = true;
        });
    }
    /**
     * Disables the given snap. A snap can only be started if it is enabled.
     *
     * @param snapId - The id of the Snap to disable.
     */
    disableSnap(snapId) {
        this.update((state) => {
            if (!state.snaps[snapId]) {
                throw new Error(`Snap "${snapId}" not found.`);
            }
            state.snaps[snapId].enabled = false;
        });
        if (this.isRunning(snapId)) {
            return this.stopSnap(snapId, SnapStatusEvent.stop);
        }
        return Promise.resolve();
    }
    /**
     * Stops the given snap, removes all hooks, closes all connections, and
     * terminates its worker.
     *
     * @param snapId - The id of the Snap to stop.
     * @param statusEvent - The Snap status event that caused the snap to be
     * stopped.
     */
    async stopSnap(snapId, statusEvent = SnapStatusEvent.stop) {
        const runtime = this._getSnapRuntimeData(snapId);
        if (!runtime) {
            return;
        }
        // Reset request tracking
        runtime.lastRequest = null;
        runtime.pendingRequests = 0;
        try {
            if (this.isRunning(snapId)) {
                this._closeAllConnections(snapId);
                await this.terminateSnap(snapId);
            }
        }
        finally {
            if (this.isRunning(snapId)) {
                this._transitionSnapState(snapId, statusEvent);
            }
        }
    }
    /**
     * Terminates the specified snap and emits the `snapTerminated` event.
     *
     * @param snapId - The snap to terminate.
     */
    async terminateSnap(snapId) {
        await this._terminateSnap(snapId);
        this.messagingSystem.publish('SnapController:snapTerminated', snapId);
    }
    /**
     * Returns whether the given snap is running.
     * Throws an error if the snap doesn't exist.
     *
     * @param snapId - The id of the Snap to check.
     */
    isRunning(snapId) {
        const snap = this.get(snapId);
        if (!snap) {
            throw new Error(`Snap "${snapId}" not found.`);
        }
        return snap.status === SnapStatus.running;
    }
    /**
     * Returns whether the given snap has been added to state.
     *
     * @param snapId - The id of the Snap to check for.
     */
    has(snapId) {
        return Boolean(this.get(snapId));
    }
    /**
     * Gets the snap with the given id if it exists, including all data.
     * This should not be used if the snap is to be serializable, as e.g.
     * the snap sourceCode may be quite large.
     *
     * @param snapId - The id of the Snap to get.
     */
    get(snapId) {
        return this.state.snaps[snapId];
    }
    /**
     * Gets the snap with the given id if it exists, excluding any
     * non-serializable or expensive-to-serialize data.
     *
     * @param snapId - The id of the Snap to get.
     */
    getTruncated(snapId) {
        const snap = this.get(snapId);
        return snap
            ? Object.keys(snap).reduce((serialized, key) => {
                if (TRUNCATED_SNAP_PROPERTIES.has(key)) {
                    serialized[key] = snap[key];
                }
                return serialized;
            }, {})
            : null;
    }
    /**
     * Updates the own state of the snap with the given id.
     * This is distinct from the state MetaMask uses to manage snaps.
     *
     * @param snapId - The id of the Snap whose state should be updated.
     * @param newSnapState - The new state of the snap.
     */
    async updateSnapState(snapId, newSnapState) {
        this.update((state) => {
            state.snapStates[snapId] = newSnapState;
        });
    }
    /**
     * Clears the state of the snap with the given id.
     * This is distinct from the state MetaMask uses to manage snaps.
     *
     * @param snapId - The id of the Snap whose state should be cleared.
     */
    async clearSnapState(snapId) {
        this.update((state) => {
            delete state.snapStates[snapId];
        });
    }
    /**
     * Adds error from a snap to the SnapControllers state.
     *
     * @param snapError - The error to store on the SnapController
     */
    addSnapError(snapError) {
        this.update((state) => {
            const id = (0, nanoid_1.nanoid)();
            state.snapErrors[id] = {
                ...snapError,
                internalID: id,
            };
        });
    }
    /**
     * Removes an error by internalID from a the SnapControllers state.
     *
     * @param internalID - The internal error ID to remove on the SnapController
     */
    async removeSnapError(internalID) {
        this.update((state) => {
            delete state.snapErrors[internalID];
        });
    }
    /**
     * Clears all errors from the SnapControllers state.
     *
     */
    async clearSnapErrors() {
        this.update((state) => {
            state.snapErrors = {};
        });
    }
    /**
     * Gets the own state of the snap with the given id.
     * This is distinct from the state MetaMask uses to manage snaps.
     *
     * @param snapId - The id of the Snap whose state to get.
     */
    async getSnapState(snapId) {
        return this.state.snapStates[snapId] ?? null;
    }
    /**
     * Completely clear the controller's state: delete all associated data,
     * handlers, event listeners, and permissions; tear down all snap providers.
     */
    clearState() {
        const snapIds = Object.keys(this.state.snaps);
        snapIds.forEach((snapId) => {
            this._closeAllConnections(snapId);
        });
        this._terminateAllSnaps();
        snapIds.forEach(this.revokeAllSnapPermissions);
        this.update((state) => {
            state.snaps = {};
            state.snapStates = {};
        });
    }
    /**
     * Removes the given snap from state, and clears all associated handlers
     * and listeners.
     *
     * @param snapId - The id of the Snap.
     */
    async removeSnap(snapId) {
        return this.removeSnaps([snapId]);
    }
    /**
     * Stops the given snaps, removes them from state, and clears all associated
     * permissions, handlers, and listeners.
     *
     * @param snapIds - The ids of the Snaps.
     */
    async removeSnaps(snapIds) {
        if (!Array.isArray(snapIds)) {
            throw new Error('Expected array of snap ids.');
        }
        await Promise.all(snapIds.map(async (snapId) => {
            // Disable the snap and revoke all of its permissions before deleting
            // it. This ensures that the snap will not be restarted or otherwise
            // affect the host environment while we are deleting it.
            await this.disableSnap(snapId);
            this.revokeAllSnapPermissions(snapId);
            const permissionName = (0, utils_3.getSnapPermissionName)(snapId);
            // Revoke all subjects access to the snap
            this.messagingSystem.call('PermissionController:revokePermissionForAllSubjects', permissionName);
            this._snapsRuntimeData.delete(snapId);
            this.update((state) => {
                delete state.snaps[snapId];
                delete state.snapStates[snapId];
            });
            this.messagingSystem.publish(`SnapController:snapRemoved`, snapId);
        }));
    }
    /**
     * Safely revokes all permissions granted to a Snap.
     *
     * @param snapId - The snap ID.
     */
    revokeAllSnapPermissions(snapId) {
        if (this.messagingSystem.call('PermissionController:hasPermissions', snapId)) {
            this.messagingSystem.call('PermissionController:revokeAllPermissions', snapId);
        }
    }
    /**
     * Gets the serialized permitted snaps of the given origin, if any.
     * @param origin - The origin whose permitted snaps to retrieve.
     */
    getPermittedSnaps(origin) {
        return Object.values(this.messagingSystem.call('PermissionController:getPermissions', origin) ?? {}).reduce((permittedSnaps, perm) => {
            if (perm.parentCapability.startsWith(utils_3.SNAP_PREFIX)) {
                const snapId = perm.parentCapability.replace(exports.SNAP_PREFIX_REGEX, '');
                const snap = this.getTruncated(snapId);
                permittedSnaps[snapId] = snap || {
                    error: (0, eth_rpc_errors_1.serializeError)(new Error('Snap permitted but not installed.')),
                };
            }
            return permittedSnaps;
        }, {});
    }
    /**
     * Installs the snaps requested by the given origin, returning the snap
     * object if the origin is permitted to install it, and an authorization error
     * otherwise.
     *
     * @param origin - The origin that requested to install the snaps.
     * @param requestedSnaps - The snaps to install.
     * @returns An object of snap ids and snap objects, or errors if a
     * snap couldn't be installed.
     */
    async installSnaps(origin, requestedSnaps) {
        const result = {};
        await Promise.all(Object.entries(requestedSnaps).map(async ([snapId, { version: rawVersion }]) => {
            const version = (0, utils_3.resolveVersion)(rawVersion);
            const permissionName = (0, utils_3.getSnapPermissionName)(snapId);
            if (!(0, utils_3.isValidSnapVersionRange)(version)) {
                result[snapId] = {
                    error: eth_rpc_errors_1.ethErrors.rpc.invalidParams(`The "version" field must be a valid SemVer version range if specified. Received: "${version}".`),
                };
                return;
            }
            if (this.messagingSystem.call('PermissionController:hasPermission', origin, permissionName)) {
                // Attempt to install and run the snap, storing any errors that
                // occur during the process.
                result[snapId] = {
                    ...(await this.processRequestedSnap(origin, snapId, version)),
                };
            }
            else {
                // only allow the installation of permitted snaps
                result[snapId] = {
                    error: eth_rpc_errors_1.ethErrors.provider.unauthorized(`Not authorized to install snap "${snapId}". Request the permission for the snap before attempting to install it.`),
                };
            }
        }));
        return result;
    }
    /**
     * Adds, authorizes, and runs the given snap with a snap provider.
     * Results from this method should be efficiently serializable.
     *
     * @param origin - The origin requesting the snap.
     * @param _snapId - The id of the snap.
     * @param versionRange - The semver range of the snap to install.
     * @returns The resulting snap object, or an error if something went wrong.
     */
    async processRequestedSnap(origin, _snapId, versionRange) {
        try {
            this.validateSnapId(_snapId);
        }
        catch (err) {
            return {
                error: eth_rpc_errors_1.ethErrors.rpc.invalidParams(`"${_snapId}" is not a valid snap id.`),
            };
        }
        const snapId = _snapId;
        const existingSnap = this.getTruncated(snapId);
        // For devX we always re-install local snaps.
        if (existingSnap && (0, utils_3.getSnapPrefix)(snapId) !== utils_3.SnapIdPrefixes.local) {
            if ((0, semver_1.satisfies)(existingSnap.version, versionRange)) {
                return existingSnap;
            }
            if (this._featureFlags.dappsCanUpdateSnaps === true) {
                try {
                    const updateResult = await this.updateSnap(origin, snapId, versionRange);
                    if (updateResult === null) {
                        return {
                            error: eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Snap "${snapId}@${existingSnap.version}" is already installed, couldn't update to a version inside requested "${versionRange}" range.`),
                        };
                    }
                    return updateResult;
                }
                catch (err) {
                    return { error: (0, eth_rpc_errors_1.serializeError)(err) };
                }
            }
            else {
                return {
                    error: eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Version mismatch with already installed snap. ${snapId}@${existingSnap.version} doesn't satisfy requested version ${versionRange}`),
                };
            }
        }
        // Existing snaps must be stopped before overwriting
        if (existingSnap && this.isRunning(snapId)) {
            await this.stopSnap(snapId, SnapStatusEvent.stop);
        }
        try {
            const { sourceCode } = await this.add({
                origin,
                id: snapId,
                versionRange,
            });
            await this.authorize(snapId);
            await this._startSnap({
                snapId,
                sourceCode,
            });
            this.messagingSystem.publish(`SnapController:snapInstalled`, snapId);
            return this.getTruncated(snapId);
        }
        catch (err) {
            console.error(`Error when adding snap.`, err);
            if (this.has(snapId)) {
                this.removeSnap(snapId);
            }
            return { error: (0, eth_rpc_errors_1.serializeError)(err) };
        }
    }
    /**
     * Ask a user for approval, updates, re-authorizes and then restarts given snap.
     *
     * @param snapId The id of the Snap to be updated
     * @param newVersionRange A semver version range in which the maximum version will be chosen
     * @returns @type {TruncatedSnap} if updated, @type {null} otherwise
     */
    async updateSnap(origin, snapId, newVersionRange = utils_3.DEFAULT_REQUESTED_SNAP_VERSION) {
        const snap = this.get(snapId);
        if (snap === undefined) {
            throw new Error(`Could not find snap ${snapId}. Install the snap before attempting to update it.`);
        }
        if (!(0, utils_3.isValidSnapVersionRange)(newVersionRange)) {
            throw new Error(`Received invalid Snap version range: "${newVersionRange}".`);
        }
        const newSnap = await this._fetchSnap(snapId, newVersionRange);
        if (!(0, semver_1.gt)(newSnap.manifest.version, snap.version)) {
            console.warn(`Tried updating snap "${snapId}" within "${newVersionRange}" version range, but newer version "${snap.version}" is already installed`);
            return null;
        }
        const { newPermissions, unusedPermissions, approvedPermissions } = await this.calculatePermissionsChange(snapId, newSnap.manifest.initialPermissions);
        const isApproved = await this.messagingSystem.call('ApprovalController:addRequest', {
            origin,
            type: exports.SNAP_APPROVAL_UPDATE,
            requestData: {
                snapId,
                newVersion: newSnap.manifest.version,
                newPermissions,
                approvedPermissions,
            },
        }, true);
        if (!isApproved) {
            return null;
        }
        if (this.isRunning(snapId)) {
            await this.stopSnap(snapId, SnapStatusEvent.stop);
        }
        this._transitionSnapState(snapId, SnapStatusEvent.update);
        await this._set({
            origin,
            id: snapId,
            manifest: newSnap.manifest,
            sourceCode: newSnap.sourceCode,
            versionRange: newVersionRange,
        });
        const unusedPermissionsKeys = Object.keys(unusedPermissions);
        if ((0, utils_1.isNonEmptyArray)(unusedPermissionsKeys)) {
            this.messagingSystem.call('PermissionController:revokePermissions', {
                [snapId]: unusedPermissionsKeys,
            });
        }
        if ((0, utils_1.isNonEmptyArray)(Object.keys(newPermissions))) {
            this.messagingSystem.call('PermissionController:grantPermissions', {
                approvedPermissions: newPermissions,
                subject: { origin: snapId },
            });
        }
        await this._startSnap({ snapId, sourceCode: newSnap.sourceCode });
        this.messagingSystem.publish('SnapController:snapUpdated', snapId, newSnap.manifest.version, snap.version);
        return this.getTruncated(snapId);
    }
    /**
     * Returns a promise representing the complete installation of the requested snap.
     * If the snap is already being installed, the previously pending promise will be returned.
     *
     * @param snapId - The id of the Snap.
     * @param args - Object containing either the URL of the snap's manifest,
     * or the snap's manifest and source code.
     * @returns The resulting snap object.
     */
    async add(args) {
        const { id: _snapId } = args;
        this.validateSnapId(_snapId);
        const snapId = _snapId;
        if (!args ||
            !('origin' in args) ||
            !('id' in args) ||
            (!('manifest' in args) && 'sourceCode' in args) ||
            ('manifest' in args && !('sourceCode' in args))) {
            throw new Error(`Invalid add snap args for snap "${snapId}".`);
        }
        const runtime = this._getSnapRuntimeData(snapId);
        if (!runtime.installPromise) {
            console.info(`Adding snap: ${snapId}`);
            runtime.installPromise = this._set(args);
        }
        try {
            return await runtime.installPromise;
        }
        catch (err) {
            // Reset promise so users can retry installation in case the problem is temporary
            runtime.installPromise = null;
            throw err;
        }
    }
    validateSnapId(snapId) {
        if (!snapId || typeof snapId !== 'string') {
            throw new Error(`Invalid snap id: Not a string. Received "${snapId}"`);
        }
        for (const prefix of Object.values(utils_3.SnapIdPrefixes)) {
            if (snapId.startsWith(prefix) && snapId.replace(prefix, '').length > 0) {
                return;
            }
        }
        throw new Error(`Invalid snap id. Received: "${snapId}"`);
    }
    async _startSnap(snapData) {
        const { snapId } = snapData;
        if (this.isRunning(snapId)) {
            throw new Error(`Snap "${snapId}" is already started.`);
        }
        try {
            const result = await this._executeWithTimeout(snapId, this._executeSnap({
                ...snapData,
                endowments: await this._getEndowments(snapId),
            }));
            this._transitionSnapState(snapId, SnapStatusEvent.start);
            return result;
        }
        catch (err) {
            await this.terminateSnap(snapId);
            throw err;
        }
    }
    /**
     * Gets the names of all endowments that will be added to the Snap's
     * Compartment when it executes. These should be the names of global
     * JavaScript APIs accessible in the root realm of the execution environment.
     *
     * Throws an error if the endowment getter for a permission returns a truthy
     * value that is not an array of strings.
     *
     * @param snapId - The id of the snap whose SES endowments to get.
     * @returns An array of the names of the endowments.
     */
    async _getEndowments(snapId) {
        let allEndowments = [];
        for (const permissionName of this._environmentEndowmentPermissions) {
            if (this.messagingSystem.call('PermissionController:hasPermission', snapId, permissionName)) {
                const endowments = await this.messagingSystem.call('PermissionController:getEndowments', snapId, permissionName);
                if (endowments) {
                    // We don't have any guarantees about the type of the endowments
                    // value, so we have to guard at runtime.
                    if (!Array.isArray(endowments) ||
                        endowments.some((value) => typeof value !== 'string')) {
                        throw new Error('Expected an array of string endowment names.');
                    }
                    allEndowments = allEndowments.concat(endowments);
                }
            }
        }
        const dedupedEndowments = [
            ...new Set([...default_endowments_1.DEFAULT_ENDOWMENTS, ...allEndowments]),
        ];
        if (dedupedEndowments.length <
            default_endowments_1.DEFAULT_ENDOWMENTS.length + allEndowments.length) {
            console.error('Duplicate endowments found. Default endowments should not be requested.', allEndowments);
        }
        return dedupedEndowments;
    }
    /**
     * Internal method. See the "add" method.
     *
     * @param args - The add snap args.
     * @returns The resulting snap object.
     */
    async _set(args) {
        const { id: snapId, versionRange = utils_3.DEFAULT_REQUESTED_SNAP_VERSION, origin, } = args;
        let manifest, sourceCode, svgIcon;
        if ('manifest' in args) {
            manifest = args.manifest;
            sourceCode = args.sourceCode;
            (0, json_schemas_1.validateSnapJsonFile)(utils_3.NpmSnapFileNames.Manifest, manifest);
        }
        else {
            ({ manifest, sourceCode, svgIcon } = await this._fetchSnap(snapId, versionRange));
        }
        if (!(0, semver_1.satisfies)(manifest.version, versionRange)) {
            throw new Error(`Version mismatch. Manifest for ${snapId} specifies version ${manifest.version} which doesn't satisfy requested version range ${versionRange}`);
        }
        if (typeof sourceCode !== 'string' || sourceCode.length === 0) {
            throw new Error(`Invalid source code for snap "${snapId}".`);
        }
        const initialPermissions = manifest?.initialPermissions;
        if (!initialPermissions ||
            typeof initialPermissions !== 'object' ||
            Array.isArray(initialPermissions)) {
            throw new Error(`Invalid initial permissions for snap "${snapId}".`);
        }
        const snapsState = this.state.snaps;
        const existingSnap = snapsState[snapId];
        const { version } = manifest;
        const previousVersionHistory = existingSnap?.versionHistory ?? [];
        const versionHistory = [
            ...previousVersionHistory,
            {
                version,
                date: Date.now(),
                origin,
            },
        ];
        const snap = {
            // restore relevant snap state if it exists
            ...existingSnap,
            enabled: true,
            id: snapId,
            initialPermissions,
            manifest,
            permissionName: (0, utils_3.getSnapPermissionName)(snapId),
            sourceCode,
            status: snapStatusStateMachineConfig.initial,
            version,
            versionHistory,
        };
        // store the snap back in state
        this.update((state) => {
            state.snaps[snapId] = snap;
        });
        this.messagingSystem.publish(`SnapController:snapAdded`, snapId, snap, svgIcon);
        return snap;
    }
    /**
     * Fetches the manifest and source code of a snap.
     *
     * @param snapId - The id of the Snap.
     * @param versionRange - The SemVer version of the Snap to fetch.
     * @returns A tuple of the Snap manifest object and the Snap source code.
     */
    async _fetchSnap(snapId, versionRange = utils_3.DEFAULT_REQUESTED_SNAP_VERSION) {
        try {
            const snapPrefix = (0, utils_3.getSnapPrefix)(snapId);
            switch (snapPrefix) {
                case utils_3.SnapIdPrefixes.local:
                    return this._fetchLocalSnap(snapId.replace(utils_3.SnapIdPrefixes.local, ''));
                case utils_3.SnapIdPrefixes.npm:
                    return this._fetchNpmSnap(snapId.replace(utils_3.SnapIdPrefixes.npm, ''), versionRange);
                /* istanbul ignore next */
                default:
                    // This whill fail to compile if the above switch is not fully exhaustive
                    return (0, __1.assertExhaustive)(snapPrefix);
            }
        }
        catch (error) {
            throw new Error(`Failed to fetch Snap "${snapId}": ${error.message}`);
        }
    }
    async _fetchNpmSnap(packageName, versionRange) {
        if (!(0, utils_3.isValidSnapVersionRange)(versionRange)) {
            throw new Error(`Received invalid Snap version range: "${versionRange}".`);
        }
        const { manifest, sourceCode, svgIcon } = await (0, utils_3.fetchNpmSnap)(packageName, versionRange, this._npmRegistryUrl, this._fetchFunction);
        return { manifest, sourceCode, svgIcon };
    }
    /**
     * Fetches the manifest and source code of a local snap.
     *
     * @param localhostUrl - The localhost URL to download from.
     * @returns The validated manifest and the source code.
     */
    async _fetchLocalSnap(localhostUrl) {
        // Local snaps are mostly used for development purposes. Fetches were cached in the browser and were not requested
        // afterwards which lead to confusing development where old versions of snaps were installed.
        // Thus we disable caching
        const fetchOptions = { cache: 'no-cache' };
        const manifestUrl = new URL(utils_3.NpmSnapFileNames.Manifest, localhostUrl);
        if (!utils_3.LOCALHOST_HOSTNAMES.has(manifestUrl.hostname)) {
            throw new Error(`Invalid URL: Locally hosted Snaps must be hosted on localhost. Received URL: "${manifestUrl.toString()}"`);
        }
        const _manifest = await (await this._fetchFunction(manifestUrl.toString(), fetchOptions)).json();
        (0, json_schemas_1.validateSnapJsonFile)(utils_3.NpmSnapFileNames.Manifest, _manifest);
        const manifest = _manifest;
        const { source: { location: { npm: { filePath, iconPath }, }, }, } = manifest;
        const [sourceCode, svgIcon] = await Promise.all([
            (await this._fetchFunction(new URL(filePath, localhostUrl).toString(), fetchOptions)).text(),
            iconPath
                ? (await this._fetchFunction(new URL(iconPath, localhostUrl).toString(), fetchOptions)).text()
                : undefined,
        ]);
        (0, utils_3.validateSnapShasum)(manifest, sourceCode);
        return { manifest, sourceCode, svgIcon };
    }
    /**
     * Initiates a request for the given snap's initial permissions.
     * Must be called in order. See processRequestedSnap.
     *
     * @param snapId - The id of the Snap.
     * @returns The snap's approvedPermissions.
     */
    async authorize(snapId) {
        console.info(`Authorizing snap: ${snapId}`);
        const snapsState = this.state.snaps;
        const snap = snapsState[snapId];
        const { initialPermissions } = snap;
        try {
            // If we are re-authorizing after updating a snap, we revoke all unused permissions,
            // and only ask to authorize the new ones.
            const { newPermissions, unusedPermissions } = await this.calculatePermissionsChange(snapId, initialPermissions);
            const unusedPermissionsKeys = Object.keys(unusedPermissions);
            if ((0, utils_1.isNonEmptyArray)(unusedPermissionsKeys)) {
                this.messagingSystem.call('PermissionController:revokePermissions', {
                    [snapId]: unusedPermissionsKeys,
                });
            }
            if ((0, utils_1.isNonEmptyArray)(Object.keys(newPermissions))) {
                const [approvedPermissions] = await this.messagingSystem.call('PermissionController:requestPermissions', { origin: snapId }, newPermissions);
                return Object.values(approvedPermissions).map((perm) => perm.parentCapability);
            }
            return [];
        }
        finally {
            const runtime = this._getSnapRuntimeData(snapId);
            runtime.installPromise = null;
        }
    }
    destroy() {
        super.destroy();
        if (this._timeoutForLastRequestStatus) {
            clearTimeout(this._timeoutForLastRequestStatus);
        }
        this.messagingSystem.unsubscribe('ExecutionService:unhandledError', this._onUnhandledSnapError);
    }
    /**
     * Gets the RPC message handler for the given snap.
     *
     * @param snapId - The id of the Snap whose message handler to get.
     */
    async getRpcMessageHandler(snapId) {
        const runtime = this._getSnapRuntimeData(snapId);
        const existingHandler = runtime?.rpcHandler;
        if (existingHandler) {
            return existingHandler;
        }
        const requestQueue = new RequestQueue_1.RequestQueue(5);
        // We need to set up this promise map to map snapIds to their respective startPromises,
        // because otherwise we would lose context on the correct startPromise.
        const startPromises = new Map();
        const rpcHandler = async (origin, request) => {
            if (this.state.snaps[snapId].enabled === false) {
                throw new Error(`Snap "${snapId}" is disabled.`);
            }
            if (this.state.snaps[snapId].status === SnapStatus.installing) {
                throw new Error(`Snap "${snapId}" is currently being installed. Please try again later.`);
            }
            let handler = await this._getRpcMessageHandler(snapId);
            if (this.isRunning(snapId) === false) {
                if (handler) {
                    throw new Error('This snap should not have a handler in its current state. This is a bug, please report it.');
                }
                let localStartPromise = startPromises.get(snapId);
                if (!localStartPromise) {
                    localStartPromise = this.startSnap(snapId);
                    startPromises.set(snapId, localStartPromise);
                }
                else if (requestQueue.get(origin) >= requestQueue.maxQueueSize) {
                    throw new Error('Exceeds maximum number of requests waiting to be resolved, please try again.');
                }
                requestQueue.increment(origin);
                try {
                    await localStartPromise;
                }
                finally {
                    requestQueue.decrement(origin);
                    // Only delete startPromise for a snap if its value hasn't changed
                    if (startPromises.get(snapId) === localStartPromise) {
                        startPromises.delete(snapId);
                    }
                }
                handler = await this._getRpcMessageHandler(snapId);
            }
            if (!handler) {
                throw new Error(`Snap execution service returned no RPC handler for running snap "${snapId}".`);
            }
            let _request = request;
            if (!(0, utils_1.hasProperty)(request, 'jsonrpc')) {
                _request = { ...request, jsonrpc: '2.0' };
            }
            else if (request.jsonrpc !== '2.0') {
                throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
                    message: 'Invalid "jsonrpc" property. Must be "2.0" if provided.',
                    data: request.jsonrpc,
                });
            }
            this._recordSnapRpcRequestStart(snapId);
            // This will either get the result or reject due to the timeout.
            try {
                const result = await this._executeWithTimeout(snapId, handler(origin, _request));
                this._recordSnapRpcRequestFinish(snapId);
                return result;
            }
            catch (err) {
                await this.stopSnap(snapId, SnapStatusEvent.crash);
                throw err;
            }
        };
        runtime.rpcHandler = rpcHandler;
        return rpcHandler;
    }
    /**
     * Awaits the specified promise and rejects if the promise doesn't resolve
     * before the timeout.
     *
     * @param snapId - The snap id.
     * @param promise - The promise to await.
     * @returns The result of the promise or rejects if the promise times out.
     */
    async _executeWithTimeout(snapId, promise) {
        const isLongRunning = this.messagingSystem.call('PermissionController:hasPermission', snapId, endowments_1.LONG_RUNNING_PERMISSION);
        // Long running snaps have timeouts disabled
        if (isLongRunning) {
            return promise;
        }
        // Handle max request time
        let timeout;
        const timeoutPromise = new Promise((_resolve, reject) => {
            timeout = setTimeout(async () => {
                reject(new Error('The request timed out.'));
            }, this._maxRequestTime);
        });
        // This will either get the result or reject due to the timeout.
        const result = await Promise.race([promise, timeoutPromise]);
        clearTimeout(timeout);
        return result;
    }
    _recordSnapRpcRequestStart(snapId) {
        const runtime = this._getSnapRuntimeData(snapId);
        runtime.pendingRequests += 1;
        runtime.lastRequest = null;
    }
    _recordSnapRpcRequestFinish(snapId) {
        const runtime = this._getSnapRuntimeData(snapId);
        runtime.pendingRequests -= 1;
        if (runtime.pendingRequests === 0) {
            runtime.lastRequest = Date.now();
        }
    }
    _getSnapRuntimeData(snapId) {
        if (!this._snapsRuntimeData.has(snapId)) {
            this._snapsRuntimeData.set(snapId, {
                lastRequest: null,
                rpcHandler: null,
                installPromise: null,
                pendingRequests: 0,
            });
        }
        return this._snapsRuntimeData.get(snapId);
    }
    async calculatePermissionsChange(snapId, desiredPermissionsSet) {
        const oldPermissions = (await this.messagingSystem.call('PermissionController:getPermissions', snapId)) ?? {};
        const newPermissions = (0, utils_2.setDiff)(desiredPermissionsSet, oldPermissions);
        // TODO(ritave): The assumption that these are unused only holds so long as we do not
        //               permit dynamic permission requests.
        const unusedPermissions = (0, utils_2.setDiff)(oldPermissions, desiredPermissionsSet);
        // It's a Set Intersection of oldPermissions and desiredPermissionsSet
        // oldPermissions ∖ (oldPermissions ∖ desiredPermissionsSet) ⟺ oldPermissions ∩ desiredPermissionsSet
        const approvedPermissions = (0, utils_2.setDiff)(oldPermissions, unusedPermissions);
        return { newPermissions, unusedPermissions, approvedPermissions };
    }
}
exports.SnapController = SnapController;
//# sourceMappingURL=SnapController.js.map