"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnapController = exports.SnapStatusEvent = exports.SnapStatus = exports.SNAP_PREFIX_REGEX = exports.SNAP_PREFIX = exports.controllerName = void 0;
const controllers_1 = require("@metamask/controllers");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const nanoid_1 = require("nanoid");
const semver_1 = require("semver");
const __1 = require("..");
const utils_1 = require("../utils");
const default_endowments_1 = require("./default-endowments");
const json_schemas_1 = require("./json-schemas");
const utils_2 = require("./utils");
const RequestQueue_1 = require("./RequestQueue");
exports.controllerName = 'SnapController';
exports.SNAP_PREFIX = 'wallet_snap_';
exports.SNAP_PREFIX_REGEX = new RegExp(`^${exports.SNAP_PREFIX}`, 'u');
const TRUNCATED_SNAP_PROPERTIES = new Set([
    'initialPermissions',
    'id',
    'permissionName',
    'version',
]);
const defaultState = {
    snapErrors: {},
    snaps: {},
    snapStates: {},
};
var SnapStatus;
(function (SnapStatus) {
    SnapStatus["installing"] = "installing";
    SnapStatus["running"] = "running";
    SnapStatus["stopped"] = "stopped";
    SnapStatus["crashed"] = "crashed";
})(SnapStatus = exports.SnapStatus || (exports.SnapStatus = {}));
var SnapStatusEvent;
(function (SnapStatusEvent) {
    SnapStatusEvent["start"] = "start";
    SnapStatusEvent["stop"] = "stop";
    SnapStatusEvent["crash"] = "crash";
    SnapStatusEvent["update"] = "update";
})(SnapStatusEvent = exports.SnapStatusEvent || (exports.SnapStatusEvent = {}));
/**
 * Guard transitioning when the snap is disabled.
 */
const disabledGuard = (serializedSnap) => {
    return serializedSnap.enabled;
};
/**
 * The state machine configuration for a snaps `status` state.
 * Using a state machine for a snaps `status` ensures that the snap transitions to a valid next lifecycle state.
 * Supports a very minimal subset of XState conventions outlined in `_transitionSnapState`.
 */
const snapStatusStateMachineConfig = {
    initial: SnapStatus.installing,
    states: {
        [SnapStatus.installing]: {
            on: {
                [SnapStatusEvent.start]: {
                    target: SnapStatus.running,
                    cond: disabledGuard,
                },
            },
        },
        [SnapStatus.running]: {
            on: {
                [SnapStatusEvent.stop]: SnapStatus.stopped,
                [SnapStatusEvent.crash]: SnapStatus.crashed,
            },
        },
        [SnapStatus.stopped]: {
            on: {
                [SnapStatusEvent.start]: {
                    target: SnapStatus.running,
                    cond: disabledGuard,
                },
                [SnapStatusEvent.update]: SnapStatus.installing,
            },
        },
        [SnapStatus.crashed]: {
            on: {
                [SnapStatusEvent.start]: {
                    target: SnapStatus.running,
                    cond: disabledGuard,
                },
            },
        },
    },
};
const name = 'SnapController';
/*
 * A snap is initialized in three phases:
 * - Add: Loads the snap from a remote source and parses it.
 * - Authorize: Requests the snap's required permissions from the user.
 * - Start: Initializes the snap in its SES realm with the authorized permissions.
 */
class SnapController extends controllers_1.BaseControllerV2 {
    constructor({ closeAllConnections, executeSnap, getRpcMessageHandler, messenger, state, terminateAllSnaps, terminateSnap, endowmentPermissionNames = [], npmRegistryUrl, idleTimeCheckInterval = 5000, maxIdleTime = 30000, maxRequestTime = 60000, }) {
        super({
            messenger,
            metadata: {
                snapErrors: {
                    persist: false,
                    anonymous: false,
                },
                snapStates: {
                    persist: true,
                    anonymous: false,
                },
                snaps: {
                    persist: (snaps) => {
                        return Object.values(snaps)
                            .map((snap) => {
                            return Object.assign(Object.assign({}, snap), { 
                                // At the time state is rehydrated, no snap will be running.
                                status: SnapStatus.stopped });
                        })
                            .reduce((memo, snap) => {
                            memo[snap.id] = snap;
                            return memo;
                        }, {});
                    },
                    anonymous: false,
                },
            },
            name,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this._closeAllConnections = closeAllConnections;
        this._endowmentPermissionNames = endowmentPermissionNames;
        this._executeSnap = executeSnap;
        this._getRpcMessageHandler = getRpcMessageHandler;
        this._onUnhandledSnapError = this._onUnhandledSnapError.bind(this);
        this._onUnresponsiveSnap = this._onUnresponsiveSnap.bind(this);
        this._terminateSnap = terminateSnap;
        this._terminateAllSnaps = terminateAllSnaps;
        this._idleTimeCheckInterval = idleTimeCheckInterval;
        this._maxIdleTime = maxIdleTime;
        this._maxRequestTime = maxRequestTime;
        this._pollForLastRequestStatus();
        this._snapsRuntimeData = new Map();
        this._npmRegistryUrl = npmRegistryUrl;
        this.messagingSystem.subscribe('ExecutionService:unhandledError', this._onUnhandledSnapError);
        this.messagingSystem.subscribe('ExecutionService:unresponsive', this._onUnresponsiveSnap);
        this.registerMessageHandlers();
    }
    /**
     * Constructor helper for registering the controller's messaging system
     * actions.
     */
    registerMessageHandlers() {
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:add`, (...args) => this.add(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:get`, (...args) => this.get(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:getRpcMessageHandler`, (...args) => this.getRpcMessageHandler(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:getSnapState`, (...args) => this.getSnapState(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:has`, (...args) => this.has(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:updateSnapState`, (...args) => this.updateSnapState(...args));
    }
    _pollForLastRequestStatus() {
        this._timeoutForLastRequestStatus = setTimeout(async () => {
            this._stopSnapsLastRequestPastMax();
            this._pollForLastRequestStatus();
        }, this._idleTimeCheckInterval);
    }
    _stopSnapsLastRequestPastMax() {
        this._snapsRuntimeData.forEach(async (runtime, snapId) => {
            if (runtime.lastRequest &&
                this._maxIdleTime &&
                utils_1.timeSince(runtime.lastRequest) > this._maxIdleTime) {
                this.stopSnap(snapId, SnapStatusEvent.stop);
            }
        });
    }
    async _onUnresponsiveSnap(snapId) {
        await this.stopSnap(snapId, SnapStatusEvent.crash);
        this.addSnapError({
            // TODO: Standardize error code
            code: eth_rpc_errors_1.errorCodes.rpc.internal,
            message: 'Snap Unresponsive',
            data: {
                snapId,
            },
        });
    }
    async _onUnhandledSnapError(snapId, error) {
        await this.stopSnap(snapId, SnapStatusEvent.crash);
        this.addSnapError(error);
    }
    /**
     * Transitions between states using `snapStatusStateMachineConfig` as the template to figure out the next state.
     * This transition function uses a very minimal subset of XState conventions:
     * - supports initial state
     * - .on supports raw event target string
     * - .on supports {target, cond} object
     * - the arguments for `cond` is the `SerializedSnap` instead of Xstate convention of `(event, context) => boolean`
     *
     * @param snapId - The id of the snap to transition
     * @param event - The event enum to use to transition
     */
    _transitionSnapState(snapId, event) {
        var _a;
        const snapStatus = this.state.snaps[snapId].status;
        let nextStatus = (_a = snapStatusStateMachineConfig.states[snapStatus].on[event]) !== null && _a !== void 0 ? _a : snapStatus;
        if (nextStatus.cond) {
            const cond = nextStatus.cond(this.state.snaps[snapId]);
            if (cond === false) {
                throw new Error(`Condition failed for state transition "${snapId}" with event "${event}".`);
            }
        }
        if (nextStatus.target) {
            nextStatus = nextStatus.target;
        }
        if (nextStatus === snapStatus) {
            return;
        }
        this.update((state) => {
            state.snaps[snapId].status = nextStatus;
        });
    }
    /**
     * Starts the given snap. Throws an error if no such snap exists
     * or if it is already running.
     *
     * @param snapId - The id of the Snap to start.
     */
    async startSnap(snapId) {
        const snap = this.get(snapId);
        if (!snap) {
            throw new Error(`Snap "${snapId}" not found.`);
        }
        if (this.state.snaps[snapId].enabled === false) {
            throw new Error(`Snap "${snapId}" is disabled.`);
        }
        await this._startSnap({
            snapId,
            sourceCode: snap.sourceCode,
        });
    }
    /**
     * Enables the given snap. A snap can only be started if it is enabled.
     *
     * @param snapId - The id of the Snap to enable.
     */
    enableSnap(snapId) {
        this.update((state) => {
            state.snaps[snapId].enabled = true;
        });
    }
    /**
     * Disables the given snap. A snap can only be started if it is enabled.
     *
     * @param snapId - The id of the Snap to disable.
     */
    disableSnap(snapId) {
        this.update((state) => {
            if (!state.snaps[snapId]) {
                throw new Error(`Snap "${snapId}" not found.`);
            }
            state.snaps[snapId].enabled = false;
        });
        if (this.isRunning(snapId)) {
            return this.stopSnap(snapId, SnapStatusEvent.stop);
        }
        return Promise.resolve();
    }
    /**
     * Stops the given snap, removes all hooks, closes all connections, and
     * terminates its worker.
     *
     * @param snapId - The id of the Snap to stop.
     * @param statusEvent - The Snap status event that caused the snap to be
     * stopped.
     */
    async stopSnap(snapId, statusEvent = SnapStatusEvent.stop) {
        const runtime = this._getSnapRuntimeData(snapId);
        if (!runtime) {
            return;
        }
        runtime.lastRequest = null;
        try {
            if (this.isRunning(snapId)) {
                this._closeAllConnections(snapId);
                await this._terminateSnap(snapId);
            }
        }
        finally {
            if (this.isRunning(snapId)) {
                this._transitionSnapState(snapId, statusEvent);
            }
        }
    }
    /**
     * Returns whether the given snap is running.
     * Throws an error if the snap doesn't exist.
     *
     * @param snapId - The id of the Snap to check.
     */
    isRunning(snapId) {
        const snap = this.get(snapId);
        if (!snap) {
            throw new Error(`Snap "${snapId}" not found.`);
        }
        return snap.status === SnapStatus.running;
    }
    /**
     * Returns whether the given snap has been added to state.
     *
     * @param snapId - The id of the Snap to check for.
     */
    has(snapId) {
        return Boolean(this.get(snapId));
    }
    /**
     * Gets the snap with the given id if it exists, including all data.
     * This should not be used if the snap is to be serializable, as e.g.
     * the snap sourceCode may be quite large.
     *
     * @param snapId - The id of the Snap to get.
     */
    get(snapId) {
        return this.state.snaps[snapId];
    }
    /**
     * Gets the snap with the given id if it exists, excluding any
     * non-serializable or expensive-to-serialize data.
     *
     * @param snapId - The id of the Snap to get.
     */
    getTruncated(snapId) {
        const snap = this.get(snapId);
        return snap
            ? Object.keys(snap).reduce((serialized, key) => {
                if (TRUNCATED_SNAP_PROPERTIES.has(key)) {
                    serialized[key] = snap[key];
                }
                return serialized;
            }, {})
            : null;
    }
    /**
     * Updates the own state of the snap with the given id.
     * This is distinct from the state MetaMask uses to manage snaps.
     *
     * @param snapId - The id of the Snap whose state should be updated.
     * @param newSnapState - The new state of the snap.
     */
    async updateSnapState(snapId, newSnapState) {
        this.update((state) => {
            state.snapStates[snapId] = newSnapState;
        });
    }
    /**
     * Adds error from a snap to the SnapControllers state.
     *
     * @param snapError - The error to store on the SnapController
     */
    addSnapError(snapError) {
        this.update((state) => {
            const id = nanoid_1.nanoid();
            state.snapErrors[id] = Object.assign(Object.assign({}, snapError), { internalID: id });
        });
    }
    /**
     * Removes an error by internalID from a the SnapControllers state.
     *
     * @param internalID - The internal error ID to remove on the SnapController
     */
    async removeSnapError(internalID) {
        this.update((state) => {
            delete state.snapErrors[internalID];
        });
    }
    /**
     * Clears all errors from the SnapControllers state.
     *
     */
    async clearSnapErrors() {
        this.update((state) => {
            state.snapErrors = {};
        });
    }
    /**
     * Gets the own state of the snap with the given id.
     * This is distinct from the state MetaMask uses to manage snaps.
     *
     * @param snapId - The id of the Snap whose state to get.
     */
    async getSnapState(snapId) {
        var _a;
        return (_a = this.state.snapStates[snapId]) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Completely clear the controller's state: delete all associated data,
     * handlers, event listeners, and permissions; tear down all snap providers.
     */
    clearState() {
        const snapIds = Object.keys(this.state.snaps);
        snapIds.forEach((snapId) => {
            this._closeAllConnections(snapId);
        });
        this._terminateAllSnaps();
        snapIds.forEach(this.revokeAllSnapPermissions);
        this.update((state) => {
            state.snaps = {};
            state.snapStates = {};
        });
    }
    /**
     * Removes the given snap from state, and clears all associated handlers
     * and listeners.
     *
     * @param snapId - The id of the Snap.
     */
    async removeSnap(snapId) {
        return this.removeSnaps([snapId]);
    }
    /**
     * Stops the given snaps, removes them from state, and clears all associated
     * permissions, handlers, and listeners.
     *
     * @param snapIds - The ids of the Snaps.
     */
    async removeSnaps(snapIds) {
        if (!Array.isArray(snapIds)) {
            throw new Error('Expected array of snap ids.');
        }
        await Promise.all(snapIds.map(async (snapId) => {
            // Disable the snap and revoke all of its permissions before deleting
            // it. This ensures that the snap will not be restarted or otherwise
            // affect the host environment while we are deleting it.
            await this.disableSnap(snapId);
            this.revokeAllSnapPermissions(snapId);
            this._snapsRuntimeData.delete(snapId);
            this.update((state) => {
                delete state.snaps[snapId];
                delete state.snapStates[snapId];
            });
            this.messagingSystem.publish(`SnapController:snapRemoved`, snapId);
        }));
    }
    /**
     * Safely revokes all permissions granted to a Snap.
     *
     * @param snapId - The snap ID.
     */
    revokeAllSnapPermissions(snapId) {
        if (this.messagingSystem.call('PermissionController:hasPermissions', snapId)) {
            this.messagingSystem.call('PermissionController:revokeAllPermissions', snapId);
        }
    }
    /**
     * Gets the serialized permitted snaps of the given origin, if any.
     * @param origin - The origin whose permitted snaps to retrieve.
     */
    getPermittedSnaps(origin) {
        var _a;
        return Object.values((_a = this.messagingSystem.call('PermissionController:getPermissions', origin)) !== null && _a !== void 0 ? _a : {}).reduce((permittedSnaps, perm) => {
            if (perm.parentCapability.startsWith(exports.SNAP_PREFIX)) {
                const snapId = perm.parentCapability.replace(exports.SNAP_PREFIX_REGEX, '');
                const snap = this.getTruncated(snapId);
                permittedSnaps[snapId] = snap || {
                    error: eth_rpc_errors_1.serializeError(new Error('Snap permitted but not installed.')),
                };
            }
            return permittedSnaps;
        }, {});
    }
    /**
     * Installs the snaps requested by the given origin, returning the snap
     * object if the origin is permitted to install it, and an authorization error
     * otherwise.
     *
     * @param origin - The origin that requested to install the snaps.
     * @param requestedSnaps - The snaps to install.
     * @returns An object of snap ids and snap objects, or errors if a
     * snap couldn't be installed.
     */
    async installSnaps(origin, requestedSnaps) {
        const result = {};
        await Promise.all(Object.entries(requestedSnaps).map(async ([snapId, { version: rawVersion }]) => {
            const version = utils_2.resolveVersion(rawVersion);
            const permissionName = exports.SNAP_PREFIX + snapId;
            if (!utils_2.isValidSnapVersionRange(version)) {
                result[snapId] = {
                    error: eth_rpc_errors_1.ethErrors.rpc.invalidParams(`The "version" field must be a valid SemVer version range if specified. Received: "${version}".`),
                };
                return;
            }
            if (this.messagingSystem.call('PermissionController:hasPermission', origin, permissionName)) {
                // Attempt to install and run the snap, storing any errors that
                // occur during the process.
                result[snapId] = Object.assign({}, (await this.processRequestedSnap(origin, snapId, version)));
            }
            else {
                // only allow the installation of permitted snaps
                result[snapId] = {
                    error: eth_rpc_errors_1.ethErrors.provider.unauthorized(`Not authorized to install snap "${snapId}". Request the permission for the snap before attempting to install it.`),
                };
            }
        }));
        return result;
    }
    /**
     * Adds, authorizes, and runs the given snap with a snap provider.
     * Results from this method should be efficiently serializable.
     *
     * @param origin - The origin requesting the snap.
     * @param snapId - The id of the snap.
     * @param version - The version of the snap to install.
     * @returns The resulting snap object, or an error if something went wrong.
     */
    async processRequestedSnap(origin, snapId, version) {
        const existingSnap = this.getTruncated(snapId);
        // For devX we always re-install local snaps.
        if (existingSnap && !snapId.startsWith(utils_2.SnapIdPrefixes.local)) {
            if (semver_1.satisfies(existingSnap.version, version)) {
                return existingSnap;
            }
            return {
                error: eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Version mismatch with already installed snap. ${snapId}@${existingSnap.version} doesn't satisfy requested version ${version}`),
            };
        }
        // Existing snaps must be stopped before overwriting
        if (existingSnap && this.isRunning(snapId)) {
            await this.stopSnap(snapId, SnapStatusEvent.stop);
        }
        try {
            const { sourceCode } = await this.add({
                origin,
                id: snapId,
                versionRange: version,
            });
            await this.authorize(snapId);
            await this._startSnap({
                snapId,
                sourceCode,
            });
            this.messagingSystem.publish(`SnapController:snapInstalled`, snapId);
            return this.getTruncated(snapId);
        }
        catch (err) {
            console.error(`Error when adding snap.`, err);
            if (this.has(snapId)) {
                this.removeSnap(snapId);
            }
            return { error: eth_rpc_errors_1.serializeError(err) };
        }
    }
    /**
     * Updates, re-authorizes and then restarts given snap.
     *
     * @param snapId The id of the Snap to be updated
     * @param newVersionRange A semver version range in which the maximum version will be chosen
     * @returns @type {TruncatedSnap} if updated, @type {null} otherwise
     */
    async updateSnap(origin, snapId, newVersionRange = utils_2.DEFAULT_REQUESTED_SNAP_VERSION) {
        const snap = this.get(snapId);
        if (snap === undefined) {
            throw new Error(`Could not find snap ${snapId}. Install the snap before attempting to update it.`);
        }
        if (!utils_2.isValidSnapVersionRange(newVersionRange)) {
            throw new Error(`Received invalid Snap version range: "${newVersionRange}".`);
        }
        const newSnap = await this._fetchSnap(snapId, newVersionRange);
        if (!semver_1.gt(newSnap.manifest.version, snap.version)) {
            console.warn(`Tried updating snap "${snapId}" within "${newVersionRange}" version range, but newer version "${snap.version}" is already installed`);
            return null;
        }
        if (this.isRunning(snapId)) {
            this.stopSnap(snapId, SnapStatusEvent.stop);
        }
        this._transitionSnapState(snapId, SnapStatusEvent.update);
        await this._set({
            origin,
            id: snapId,
            manifest: newSnap.manifest,
            sourceCode: newSnap.sourceCode,
            versionRange: newVersionRange,
        });
        await this.authorize(snapId);
        await this._startSnap({ snapId, sourceCode: newSnap.sourceCode });
        this.messagingSystem.publish('SnapController:snapUpdated', snapId, newSnap.manifest.version, snap.version);
        return this.getTruncated(snapId);
    }
    /**
     * Returns a promise representing the complete installation of the requested snap.
     * If the snap is already being installed, the previously pending promise will be returned.
     *
     * @param snapId - The id of the Snap.
     * @param args - Object containing either the URL of the snap's manifest,
     * or the snap's manifest and source code.
     * @returns The resulting snap object.
     */
    async add(args) {
        const { id: _snapId } = args;
        this.validateSnapId(_snapId);
        const snapId = _snapId;
        if (!args ||
            !('origin' in args) ||
            !('id' in args) ||
            (!('manifest' in args) && 'sourceCode' in args) ||
            ('manifest' in args && !('sourceCode' in args))) {
            throw new Error(`Invalid add snap args for snap "${snapId}".`);
        }
        const runtime = this._getSnapRuntimeData(snapId);
        if (!runtime.installPromise) {
            console.log(`Adding snap: ${snapId}`);
            runtime.installPromise = this._set(args);
        }
        try {
            return await runtime.installPromise;
        }
        catch (err) {
            // Reset promise so users can retry installation in case the problem is temporary
            runtime.installPromise = null;
            throw err;
        }
    }
    validateSnapId(snapId) {
        if (!snapId || typeof snapId !== 'string') {
            throw new Error(`Invalid snap id: Not a string. Received "${snapId}"`);
        }
        for (const prefix of Object.values(utils_2.SnapIdPrefixes)) {
            if (snapId.startsWith(prefix) && snapId.replace(prefix, '').length > 0) {
                return;
            }
        }
        throw new Error(`Invalid snap id. Received: "${snapId}"`);
    }
    async _startSnap(snapData) {
        const { snapId } = snapData;
        if (this.isRunning(snapId)) {
            throw new Error(`Snap "${snapId}" is already started.`);
        }
        const result = await this._executeSnap(Object.assign(Object.assign({}, snapData), { endowments: await this._getEndowments(snapId) }));
        this._transitionSnapState(snapId, SnapStatusEvent.start);
        return result;
    }
    /**
     * Gets the names of all endowments that will be added to the Snap's
     * Compartment when it executes. These should be the names of global
     * JavaScript APIs accessible in the root realm of the execution environment.
     *
     * Throws an error if the endowment getter for a permission returns a truthy
     * value that is not an array of strings.
     *
     * @param snapId - The id of the snap whose SES endowments to get.
     * @returns An array of the names of the endowments.
     */
    async _getEndowments(snapId) {
        let allEndowments = [];
        for (const permissionName of this._endowmentPermissionNames) {
            if (this.messagingSystem.call('PermissionController:hasPermission', snapId, permissionName)) {
                const endowments = await this.messagingSystem.call('PermissionController:getEndowments', snapId, permissionName);
                if (endowments) {
                    // We don't have any guarantees about the type of the endowments
                    // value, so we have to guard at runtime.
                    if (!Array.isArray(endowments) ||
                        endowments.some((value) => typeof value !== 'string')) {
                        throw new Error('Expected an array of string endowment names.');
                    }
                    allEndowments = allEndowments.concat(endowments);
                }
            }
        }
        const dedupedEndowments = [
            ...new Set([...default_endowments_1.DEFAULT_ENDOWMENTS, ...allEndowments]),
        ];
        if (dedupedEndowments.length <
            default_endowments_1.DEFAULT_ENDOWMENTS.length + allEndowments.length) {
            console.error('Duplicate endowments found. Default endowments should not be requested.', allEndowments);
        }
        return dedupedEndowments;
    }
    /**
     * Internal method. See the "add" method.
     *
     * @param args - The add snap args.
     * @returns The resulting snap object.
     */
    async _set(args) {
        var _a;
        const { id: snapId, versionRange = utils_2.DEFAULT_REQUESTED_SNAP_VERSION, origin, } = args;
        let manifest, sourceCode, svgIcon;
        if ('manifest' in args) {
            manifest = args.manifest;
            sourceCode = args.sourceCode;
            json_schemas_1.validateSnapJsonFile(utils_2.NpmSnapFileNames.Manifest, manifest);
        }
        else {
            ({ manifest, sourceCode, svgIcon } = await this._fetchSnap(snapId, versionRange));
        }
        if (!semver_1.satisfies(manifest.version, versionRange)) {
            throw new Error(`Version mismatch. Manifest for ${snapId} specifies version ${manifest.version} which doesn't satisfy requested version range ${versionRange}`);
        }
        if (typeof sourceCode !== 'string' || sourceCode.length === 0) {
            throw new Error(`Invalid source code for snap "${snapId}".`);
        }
        const initialPermissions = manifest === null || manifest === void 0 ? void 0 : manifest.initialPermissions;
        if (!initialPermissions ||
            typeof initialPermissions !== 'object' ||
            Array.isArray(initialPermissions)) {
            throw new Error(`Invalid initial permissions for snap "${snapId}".`);
        }
        const snapsState = this.state.snaps;
        const existingSnap = snapsState[snapId];
        const { version } = manifest;
        const previousVersionHistory = (_a = existingSnap === null || existingSnap === void 0 ? void 0 : existingSnap.versionHistory) !== null && _a !== void 0 ? _a : [];
        const versionHistory = [
            ...previousVersionHistory,
            {
                version,
                date: Date.now(),
                origin,
            },
        ];
        const snap = Object.assign(Object.assign({}, existingSnap), { enabled: true, id: snapId, initialPermissions,
            manifest, permissionName: exports.SNAP_PREFIX + snapId, // so we can easily correlate them
            sourceCode, status: snapStatusStateMachineConfig.initial, version,
            versionHistory });
        // store the snap back in state
        this.update((state) => {
            state.snaps[snapId] = snap;
        });
        this.messagingSystem.publish(`SnapController:snapAdded`, snapId, snap, svgIcon);
        return snap;
    }
    /**
     * Fetches the manifest and source code of a snap.
     *
     * @param snapId - The id of the Snap.
     * @param versionRange - The SemVer version of the Snap to fetch.
     * @returns A tuple of the Snap manifest object and the Snap source code.
     */
    async _fetchSnap(snapId, versionRange = utils_2.DEFAULT_REQUESTED_SNAP_VERSION) {
        try {
            const snapPrefix = utils_2.getSnapPrefix(snapId);
            switch (snapPrefix) {
                case utils_2.SnapIdPrefixes.local:
                    return this._fetchLocalSnap(snapId.replace(utils_2.SnapIdPrefixes.local, ''));
                case utils_2.SnapIdPrefixes.npm:
                    return this._fetchNpmSnap(snapId.replace(utils_2.SnapIdPrefixes.npm, ''), versionRange);
                /* istanbul ignore next */
                default:
                    // This whill fail to compile if the above switch is not fully exhaustive
                    return __1.assertExhaustive(snapPrefix);
            }
        }
        catch (error) {
            throw new Error(`Failed to fetch Snap "${snapId}": ${error.message}`);
        }
    }
    async _fetchNpmSnap(packageName, versionRange) {
        if (!utils_2.isValidSnapVersionRange(versionRange)) {
            throw new Error(`Received invalid Snap version range: "${versionRange}".`);
        }
        const { manifest, sourceCode, svgIcon } = await utils_2.fetchNpmSnap(packageName, versionRange, this._npmRegistryUrl);
        return { manifest, sourceCode, svgIcon };
    }
    /**
     * Fetches the manifest and source code of a local snap.
     *
     * @param localhostUrl - The localhost URL to download from.
     * @returns The validated manifest and the source code.
     */
    async _fetchLocalSnap(localhostUrl) {
        // Local snaps are mostly used for development purposes. Fetches were cached in the browser and were not requested
        // afterwards which lead to confusing development where old versions of snaps were installed.
        // Thus we disable caching
        const fetchOptions = { cache: 'no-cache' };
        const manifestUrl = new URL(utils_2.NpmSnapFileNames.Manifest, localhostUrl);
        if (!utils_2.LOCALHOST_HOSTNAMES.has(manifestUrl.hostname)) {
            throw new Error(`Invalid URL: Locally hosted Snaps must be hosted on localhost. Received URL: "${manifestUrl.toString()}"`);
        }
        const _manifest = await (await utils_2.fetchContent(manifestUrl.toString(), fetchOptions)).json();
        json_schemas_1.validateSnapJsonFile(utils_2.NpmSnapFileNames.Manifest, _manifest);
        const manifest = _manifest;
        const { source: { location: { npm: { filePath, iconPath }, }, }, } = manifest;
        const [sourceCode, svgIcon] = await Promise.all([
            (await utils_2.fetchContent(new URL(filePath, localhostUrl).toString(), fetchOptions)).text(),
            iconPath
                ? (await utils_2.fetchContent(new URL(iconPath, localhostUrl).toString(), fetchOptions)).text()
                : undefined,
        ]);
        utils_2.validateSnapShasum(manifest, sourceCode);
        return { manifest, sourceCode, svgIcon };
    }
    /**
     * Initiates a request for the given snap's initial permissions.
     * Must be called in order. See processRequestedSnap.
     *
     * @param snapId - The id of the Snap.
     * @returns The snap's approvedPermissions.
     */
    async authorize(snapId) {
        console.log(`Authorizing snap: ${snapId}`);
        const snapsState = this.state.snaps;
        const snap = snapsState[snapId];
        const { initialPermissions } = snap;
        // Don't prompt if there are no permissions requested:
        if (Object.keys(initialPermissions).length === 0) {
            return [];
        }
        if (initialPermissions === null) {
            return [];
        }
        try {
            // If we are re-authorizing after updating a snap, we revoke all unused permissions,
            // and only ask to authorize the new ones.
            const alreadyApprovedPermissions = await this.messagingSystem.call('PermissionController:getPermissions', snapId);
            const newPermissions = utils_1.setDiff(initialPermissions, alreadyApprovedPermissions !== null && alreadyApprovedPermissions !== void 0 ? alreadyApprovedPermissions : {});
            // TODO(ritave): The assumption that these are unused only holds so long as we do not
            //               permit dynamic permission requests.
            const unusedPermissions = Object.keys(utils_1.setDiff(alreadyApprovedPermissions !== null && alreadyApprovedPermissions !== void 0 ? alreadyApprovedPermissions : {}, initialPermissions));
            if (utils_1.isNonEmptyArray(unusedPermissions)) {
                await this.messagingSystem.call('PermissionController:revokePermissions', { [origin]: unusedPermissions });
            }
            if (utils_1.isNonEmptyArray(Object.keys(newPermissions))) {
                const [approvedPermissions] = await this.messagingSystem.call('PermissionController:requestPermissions', { origin: snapId }, newPermissions);
                return Object.values(approvedPermissions).map((perm) => perm.parentCapability);
            }
            return [];
        }
        finally {
            const runtime = this._getSnapRuntimeData(snapId);
            runtime.installPromise = null;
        }
    }
    destroy() {
        super.destroy();
        if (this._timeoutForLastRequestStatus) {
            clearTimeout(this._timeoutForLastRequestStatus);
        }
        this.messagingSystem.unsubscribe('ExecutionService:unhandledError', this._onUnhandledSnapError);
        this.messagingSystem.unsubscribe('ExecutionService:unresponsive', this._onUnresponsiveSnap);
    }
    /**
     * Gets the RPC message handler for the given snap.
     *
     * @param snapId - The id of the Snap whose message handler to get.
     */
    async getRpcMessageHandler(snapId) {
        const runtime = this._getSnapRuntimeData(snapId);
        const existingHandler = runtime === null || runtime === void 0 ? void 0 : runtime.rpcHandler;
        if (existingHandler) {
            return existingHandler;
        }
        const requestQueue = new RequestQueue_1.RequestQueue(5);
        // We need to set up this promise map to map snapIds to their respective startPromises,
        // because otherwise we would lose context on the correct startPromise.
        const startPromises = new Map();
        const rpcHandler = async (origin, request) => {
            if (this.state.snaps[snapId].enabled === false) {
                throw new Error(`Snap "${snapId}" is disabled.`);
            }
            if (this.state.snaps[snapId].status === SnapStatus.installing) {
                throw new Error(`Snap "${snapId}" is currently being installed. Please try again later.`);
            }
            let handler = await this._getRpcMessageHandler(snapId);
            if (this.isRunning(snapId) === false) {
                if (handler) {
                    throw new Error('This snap should not have a handler in its current state. This is a bug, please report it.');
                }
                let localStartPromise = startPromises.get(snapId);
                if (!localStartPromise) {
                    localStartPromise = this.startSnap(snapId);
                    startPromises.set(snapId, localStartPromise);
                }
                else if (requestQueue.get(origin) >= requestQueue.maxQueueSize) {
                    throw new Error('Exceeds maximum number of requests waiting to be resolved, please try again.');
                }
                requestQueue.increment(origin);
                try {
                    await localStartPromise;
                }
                finally {
                    requestQueue.decrement(origin);
                    // Only delete startPromise for a snap if its value hasn't changed
                    if (startPromises.get(snapId) === localStartPromise) {
                        startPromises.delete(snapId);
                    }
                }
                handler = await this._getRpcMessageHandler(snapId);
            }
            if (!handler) {
                throw new Error(`Snap execution service returned no RPC handler for running snap "${snapId}".`);
            }
            let _request = request;
            if (!Object.hasOwnProperty.call(request, 'jsonrpc')) {
                _request = Object.assign(Object.assign({}, request), { jsonrpc: '2.0' });
            }
            else if (request.jsonrpc !== '2.0') {
                throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
                    message: 'Invalid "jsonrpc" property. Must be "2.0" if provided.',
                    data: request.jsonrpc,
                });
            }
            this._recordSnapRpcRequest(snapId);
            // Handle max request time
            let timeout;
            const timeoutPromise = new Promise((_resolve, reject) => {
                timeout = setTimeout(() => {
                    this.stopSnap(snapId, SnapStatusEvent.stop);
                    reject(new Error('The request timed out.'));
                }, this._maxRequestTime);
            });
            // This will either get the result or reject due to the timeout.
            const result = await Promise.race([
                handler(origin, _request),
                timeoutPromise,
            ]);
            clearTimeout(timeout);
            return result;
        };
        runtime.rpcHandler = rpcHandler;
        return rpcHandler;
    }
    _recordSnapRpcRequest(snapId) {
        const runtime = this._getSnapRuntimeData(snapId);
        runtime.lastRequest = Date.now();
    }
    _getSnapRuntimeData(snapId) {
        if (!this._snapsRuntimeData.has(snapId)) {
            this._snapsRuntimeData.set(snapId, {
                lastRequest: null,
                rpcHandler: null,
                installPromise: null,
            });
        }
        return this._snapsRuntimeData.get(snapId);
    }
}
exports.SnapController = SnapController;
//# sourceMappingURL=SnapController.js.map