"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnapController = exports.SnapStatusEvent = exports.SnapStatus = exports.DEFAULT_EXPOSED_APIS = exports.SNAP_PREFIX_REGEX = exports.SNAP_PREFIX = exports.controllerName = void 0;
const controllers_1 = require("@metamask/controllers");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const nanoid_1 = require("nanoid");
const semver_1 = require("semver");
const utils_1 = require("../utils");
const json_schemas_1 = require("./json-schemas");
const utils_2 = require("./utils");
exports.controllerName = 'SnapController';
exports.SNAP_PREFIX = 'wallet_snap_';
exports.SNAP_PREFIX_REGEX = new RegExp(`^${exports.SNAP_PREFIX}`, 'u');
// APIs exposed by default to the Snap without needing permissions
exports.DEFAULT_EXPOSED_APIS = [
    'atob',
    'btoa',
    'BigInt',
    'Buffer',
    'console',
    'crypto',
    'Date',
    'Math',
    'setTimeout',
    'clearTimeout',
    'SubtleCrypto',
    'TextDecoder',
    'TextEncoder',
    'URL',
    'WebAssembly',
];
const TRUNCATED_SNAP_PROPERTIES = new Set([
    'initialPermissions',
    'id',
    'permissionName',
    'version',
]);
const defaultState = {
    snapErrors: {},
    snaps: {},
    snapStates: {},
};
var SnapStatus;
(function (SnapStatus) {
    SnapStatus["installing"] = "installing";
    SnapStatus["running"] = "running";
    SnapStatus["stopped"] = "stopped";
    SnapStatus["crashed"] = "crashed";
})(SnapStatus = exports.SnapStatus || (exports.SnapStatus = {}));
var SnapStatusEvent;
(function (SnapStatusEvent) {
    SnapStatusEvent["start"] = "start";
    SnapStatusEvent["stop"] = "stop";
    SnapStatusEvent["crash"] = "crash";
})(SnapStatusEvent = exports.SnapStatusEvent || (exports.SnapStatusEvent = {}));
/**
 * Guard transitioning when the snap is disabled.
 */
const disabledGuard = (serializedSnap) => {
    return serializedSnap.enabled;
};
/**
 * The state machine configuration for a snaps `status` state.
 * Using a state machine for a snaps `status` ensures that the snap transitions to a valid next lifecycle state.
 * Supports a very minimal subset of XState conventions outlined in `_transitionSnapState`.
 */
const snapStatusStateMachineConfig = {
    initial: SnapStatus.installing,
    states: {
        [SnapStatus.installing]: {
            on: {
                [SnapStatusEvent.start]: {
                    target: SnapStatus.running,
                    cond: disabledGuard,
                },
            },
        },
        [SnapStatus.running]: {
            on: {
                [SnapStatusEvent.stop]: SnapStatus.stopped,
                [SnapStatusEvent.crash]: SnapStatus.crashed,
            },
        },
        [SnapStatus.stopped]: {
            on: {
                [SnapStatusEvent.start]: {
                    target: SnapStatus.running,
                    cond: disabledGuard,
                },
            },
        },
        [SnapStatus.crashed]: {
            on: {
                [SnapStatusEvent.start]: {
                    target: SnapStatus.running,
                    cond: disabledGuard,
                },
            },
        },
    },
};
const name = 'SnapController';
/*
 * A snap is initialized in three phases:
 * - Add: Loads the snap from a remote source and parses it.
 * - Authorize: Requests the snap's required permissions from the user.
 * - Start: Initializes the snap in its SES realm with the authorized permissions.
 */
class SnapController extends controllers_1.BaseControllerV2 {
    constructor({ closeAllConnections, executeSnap, getRpcMessageHandler, messenger, state, terminateAllSnaps, terminateSnap, endowmentPermissionNames = [], npmRegistryUrl, idleTimeCheckInterval = 5000, maxIdleTime = 30000, maxRequestTime = 60000, }) {
        super({
            messenger,
            metadata: {
                snapErrors: {
                    persist: false,
                    anonymous: false,
                },
                snapStates: {
                    persist: true,
                    anonymous: false,
                },
                snaps: {
                    persist: (snaps) => {
                        return Object.values(snaps)
                            .map((snap) => {
                            return Object.assign(Object.assign({}, snap), { 
                                // At the time state is rehydrated, no snap will be running.
                                status: SnapStatus.stopped });
                        })
                            .reduce((memo, snap) => {
                            memo[snap.id] = snap;
                            return memo;
                        }, {});
                    },
                    anonymous: false,
                },
            },
            name,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this._closeAllConnections = closeAllConnections;
        this._endowmentPermissionNames = endowmentPermissionNames;
        this._executeSnap = executeSnap;
        this._getRpcMessageHandler = getRpcMessageHandler;
        this._onUnhandledSnapError = this._onUnhandledSnapError.bind(this);
        this._onUnresponsiveSnap = this._onUnresponsiveSnap.bind(this);
        this._terminateSnap = terminateSnap;
        this._terminateAllSnaps = terminateAllSnaps;
        this._idleTimeCheckInterval = idleTimeCheckInterval;
        this._maxIdleTime = maxIdleTime;
        this._maxRequestTime = maxRequestTime;
        this._pollForLastRequestStatus();
        this._snapsRuntimeData = new Map();
        this._npmRegistryUrl = npmRegistryUrl;
        this.messagingSystem.subscribe('ExecutionService:unhandledError', this._onUnhandledSnapError);
        this.messagingSystem.subscribe('ExecutionService:unresponsive', this._onUnresponsiveSnap);
        this.registerMessageHandlers();
    }
    /**
     * Constructor helper for registering the controller's messaging system
     * actions.
     */
    registerMessageHandlers() {
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:add`, (...args) => this.add(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:get`, (...args) => this.get(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:getRpcMessageHandler`, (...args) => this.getRpcMessageHandler(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:getSnapState`, (...args) => this.getSnapState(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:has`, (...args) => this.has(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:updateSnapState`, (...args) => this.updateSnapState(...args));
    }
    _pollForLastRequestStatus() {
        this._timeoutForLastRequestStatus = setTimeout(async () => {
            this._stopSnapsLastRequestPastMax();
            this._pollForLastRequestStatus();
        }, this._idleTimeCheckInterval);
    }
    _stopSnapsLastRequestPastMax() {
        this._snapsRuntimeData.forEach(async (runtime, snapId) => {
            if (runtime.lastRequest &&
                this._maxIdleTime &&
                utils_1.timeSince(runtime.lastRequest) > this._maxIdleTime) {
                this._stopSnap(snapId);
            }
        });
    }
    _onUnresponsiveSnap(snapId) {
        this._transitionSnapState(snapId, SnapStatusEvent.crash);
        this._stopSnap(snapId, false);
        this.addSnapError({
            code: -32001,
            message: 'Snap Unresponsive',
            data: {
                snapId,
            },
        });
    }
    _onUnhandledSnapError(snapId, error) {
        this._transitionSnapState(snapId, SnapStatusEvent.crash);
        this._stopSnap(snapId, false);
        this.addSnapError(error);
    }
    /**
     * Transitions between states using `snapStatusStateMachineConfig` as the template to figure out the next state.
     * This transition function uses a very minimal subset of XState conventions:
     * - supports initial state
     * - .on supports raw event target string
     * - .on supports {target, cond} object
     * - the arguments for `cond` is the `SerializedSnap` instead of Xstate convention of `(event, context) => boolean`
     *
     * @param snapId - The id of the snap to transition
     * @param event - The event enum to use to transition
     */
    _transitionSnapState(snapId, event) {
        var _a;
        const snapStatus = this.state.snaps[snapId].status;
        let nextStatus = (_a = snapStatusStateMachineConfig.states[snapStatus].on[event]) !== null && _a !== void 0 ? _a : snapStatus;
        if (nextStatus.cond) {
            const cond = nextStatus.cond(this.state.snaps[snapId]);
            if (cond === false) {
                throw new Error(`Condition failed for state transition "${snapId}" with event "${event}".`);
            }
        }
        if (nextStatus.target) {
            nextStatus = nextStatus.target;
        }
        if (nextStatus === snapStatus) {
            return;
        }
        this.update((state) => {
            state.snaps[snapId].status = nextStatus;
        });
    }
    /**
     * Starts the given snap. Throws an error if no such snap exists
     * or if it is already running.
     *
     * @param snapId - The id of the Snap to start.
     */
    async startSnap(snapId) {
        const snap = this.get(snapId);
        if (!snap) {
            throw new Error(`Snap "${snapId}" not found.`);
        }
        if (this.state.snaps[snapId].enabled === false) {
            throw new Error(`Snap "${snapId}" is disabled.`);
        }
        await this._startSnap({
            snapId,
            sourceCode: snap.sourceCode,
        });
    }
    /**
     * Enables the given snap. A snap can only be started if it is enabled.
     *
     * @param snapId - The id of the Snap to enable.
     */
    enableSnap(snapId) {
        this.update((state) => {
            state.snaps[snapId].enabled = true;
        });
    }
    /**
     * Disables the given snap. A snap can only be started if it is enabled.
     *
     * @param snapId - The id of the Snap to disable.
     */
    disableSnap(snapId) {
        this.update((state) => {
            state.snaps[snapId].enabled = false;
        });
        if (this.isRunning(snapId)) {
            return this.stopSnap(snapId);
        }
        return Promise.resolve();
    }
    /**
     * Stops the given snap. Throws an error if no such snap exists
     * or if it is already stopped.
     *
     * @param snapId - The id of the Snap to stop.
     */
    stopSnap(snapId) {
        const snap = this.get(snapId);
        if (!snap) {
            throw new Error(`Snap "${snapId}" not found.`);
        }
        if (!this.isRunning(snapId)) {
            throw new Error(`Snap "${snapId}" already stopped.`);
        }
        return this._stopSnap(snapId).then(() => {
            console.log(`Snap "${snapId}" stopped.`);
        });
    }
    /**
     * Stops the given snap, removes all hooks, closes all connections, and
     * terminates its worker.
     *
     * @param snapId - The id of the Snap to stop.
     * @param setNotRunning - Whether to mark the snap as not running. Should
     * only be set to `false` if the state is properly transitioned by the caller.
     */
    async _stopSnap(snapId, setNotRunning = true) {
        const runtime = this._getSnapRuntimeData(snapId);
        runtime.lastRequest = null;
        this._closeAllConnections(snapId);
        if (this.get(snapId) && this.isRunning(snapId)) {
            await this._terminateSnap(snapId);
        }
        if (setNotRunning) {
            this._transitionSnapState(snapId, SnapStatusEvent.stop);
        }
    }
    /**
     * Returns whether the given snap is running.
     * Throws an error if the snap doesn't exist.
     *
     * @param snapId - The id of the Snap to check.
     */
    isRunning(snapId) {
        const snap = this.get(snapId);
        if (!snap) {
            throw new Error(`Snap "${snapId}" not found.`);
        }
        return snap.status === SnapStatus.running;
    }
    /**
     * Returns whether the given snap has been added to state.
     *
     * @param snapId - The id of the Snap to check for.
     */
    has(snapId) {
        return Boolean(this.get(snapId));
    }
    /**
     * Gets the snap with the given id if it exists, including all data.
     * This should not be used if the snap is to be serializable, as e.g.
     * the snap sourceCode may be quite large.
     *
     * @param snapId - The id of the Snap to get.
     */
    get(snapId) {
        return this.state.snaps[snapId];
    }
    /**
     * Gets the snap with the given id if it exists, excluding any
     * non-serializable or expensive-to-serialize data.
     *
     * @param snapId - The id of the Snap to get.
     */
    getTruncated(snapId) {
        const snap = this.get(snapId);
        return snap
            ? Object.keys(snap).reduce((serialized, key) => {
                if (TRUNCATED_SNAP_PROPERTIES.has(key)) {
                    serialized[key] = snap[key];
                }
                return serialized;
            }, {})
            : null;
    }
    /**
     * Updates the own state of the snap with the given id.
     * This is distinct from the state MetaMask uses to manage snaps.
     *
     * @param snapId - The id of the Snap whose state should be updated.
     * @param newSnapState - The new state of the snap.
     */
    async updateSnapState(snapId, newSnapState) {
        this.update((state) => {
            state.snapStates[snapId] = newSnapState;
        });
    }
    /**
     * Adds error from a snap to the SnapControllers state.
     *
     * @param snapError - The error to store on the SnapController
     */
    async addSnapError(snapError) {
        this.update((state) => {
            const id = nanoid_1.nanoid();
            state.snapErrors[id] = Object.assign(Object.assign({}, snapError), { internalID: id });
        });
    }
    /**
     * Removes an error by internalID from a the SnapControllers state.
     *
     * @param internalID - The internal error ID to remove on the SnapController
     */
    async removeSnapError(internalID) {
        this.update((state) => {
            delete state.snapErrors[internalID];
        });
    }
    /**
     * Clears all errors from the SnapControllers state.
     *
     */
    async clearSnapErrors() {
        this.update((state) => {
            state.snapErrors = {};
        });
    }
    /**
     * Gets the own state of the snap with the given id.
     * This is distinct from the state MetaMask uses to manage snaps.
     *
     * @param snapId - The id of the Snap whose state to get.
     */
    async getSnapState(snapId) {
        var _a;
        return (_a = this.state.snapStates[snapId]) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Completely clear the controller's state: delete all associated data,
     * handlers, event listeners, and permissions; tear down all snap providers.
     */
    clearState() {
        const snapIds = Object.keys(this.state.snaps);
        snapIds.forEach((snapId) => {
            this._closeAllConnections(snapId);
        });
        this._terminateAllSnaps();
        snapIds.forEach((snapId) => this.messagingSystem.call('PermissionController:revokeAllPermissions', snapId));
        this.update((state) => {
            state.snaps = {};
            state.snapStates = {};
        });
    }
    /**
     * Removes the given snap from state, and clears all associated handlers
     * and listeners.
     *
     * @param snapId - The id of the Snap.
     */
    async removeSnap(snapId) {
        return this.removeSnaps([snapId]);
    }
    /**
     * Stops the given snaps, removes them from state, and clears all associated
     * permissions, handlers, and listeners.
     *
     * @param snapIds - The ids of the Snaps.
     */
    async removeSnaps(snapIds) {
        if (!Array.isArray(snapIds)) {
            throw new Error('Expected array of snap ids.');
        }
        await Promise.all(snapIds.map(async (snapId) => {
            // Disable the snap and revoke all of its permissions before deleting
            // it. This ensures that the snap will not be restarted or otherwise
            // affect the host environment while we are deleting it.
            await this.disableSnap(snapId);
            this.messagingSystem.call('PermissionController:revokeAllPermissions', snapId);
            this._snapsRuntimeData.delete(snapId);
            this.update((state) => {
                delete state.snaps[snapId];
                delete state.snapStates[snapId];
            });
            this.messagingSystem.publish(`SnapController:snapRemoved`, snapId);
        }));
    }
    /**
     * Gets the serialized permitted snaps of the given origin, if any.
     * @param origin - The origin whose permitted snaps to retrieve.
     */
    getPermittedSnaps(origin) {
        var _a;
        return Object.values((_a = this.messagingSystem.call('PermissionController:getPermissions', origin)) !== null && _a !== void 0 ? _a : {}).reduce((permittedSnaps, perm) => {
            if (perm.parentCapability.startsWith(exports.SNAP_PREFIX)) {
                const snapId = perm.parentCapability.replace(exports.SNAP_PREFIX_REGEX, '');
                const snap = this.getTruncated(snapId);
                permittedSnaps[snapId] = snap || {
                    error: eth_rpc_errors_1.serializeError(new Error('Snap permitted but not installed.')),
                };
            }
            return permittedSnaps;
        }, {});
    }
    /**
     * Installs the snaps requested by the given origin, returning the snap
     * object if the origin is permitted to install it, and an authorization error
     * otherwise.
     *
     * @param origin - The origin that requested to install the snaps.
     * @param requestedSnaps - The snaps to install.
     * @returns An object of snap ids and snap objects, or errors if a
     * snap couldn't be installed.
     */
    async installSnaps(origin, requestedSnaps) {
        const result = {};
        await Promise.all(Object.entries(requestedSnaps).map(async ([snapId, { version = utils_2.DEFAULT_REQUESTED_SNAP_VERSION }]) => {
            const permissionName = exports.SNAP_PREFIX + snapId;
            if (!isValidSnapVersionRange(version)) {
                result[snapId] = {
                    error: eth_rpc_errors_1.ethErrors.rpc.invalidParams(`The "version" field must be a valid SemVer version range if specified. Received: "${version}".`),
                };
                return;
            }
            if (this.messagingSystem.call('PermissionController:hasPermission', origin, permissionName)) {
                // Attempt to install and run the snap, storing any errors that
                // occur during the process.
                result[snapId] = Object.assign({}, (await this.processRequestedSnap(snapId, version)));
            }
            else {
                // only allow the installation of permitted snaps
                result[snapId] = {
                    error: eth_rpc_errors_1.ethErrors.provider.unauthorized(`Not authorized to install snap "${snapId}". Request the permission for the snap before attempting to install it.`),
                };
            }
        }));
        return result;
    }
    /**
     * Adds, authorizes, and runs the given snap with a snap provider.
     * Results from this method should be efficiently serializable.
     *
     * @param snapId - The id of the snap.
     * @param version - The version of the snap to install.
     * @returns The resulting snap object, or an error if something went wrong.
     */
    async processRequestedSnap(snapId, version) {
        const existingSnap = this.getTruncated(snapId);
        if (existingSnap) {
            if (semver_1.satisfies(existingSnap.version, version)) {
                return existingSnap;
            }
            return {
                error: eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Version mismatch with already installed snap. ${snapId}@${existingSnap.version} doesn't satisfy requested version ${version}`),
            };
        }
        try {
            const { sourceCode } = await this.add({
                id: snapId,
                version,
            });
            await this.authorize(snapId);
            await this._startSnap({
                snapId,
                sourceCode,
            });
            this.messagingSystem.publish(`SnapController:snapInstalled`, snapId);
            return this.getTruncated(snapId);
        }
        catch (err) {
            console.error(`Error when adding snap.`, err);
            if (this.has(snapId)) {
                this.removeSnap(snapId);
            }
            return { error: eth_rpc_errors_1.serializeError(err) };
        }
    }
    /**
     * Returns a promise representing the complete installation of the requested snap.
     * If the snap is already being installed, the previously pending promise will be returned.
     *
     * @param snapId - The id of the Snap.
     * @param args - Object containing either the URL of the snap's manifest,
     * or the snap's manifest and source code.
     * @returns The resulting snap object.
     */
    add(args) {
        const { id: _snapId } = args;
        this.validateSnapId(_snapId);
        const snapId = _snapId;
        if (!args ||
            !('id' in args) ||
            (!('manifest' in args) && 'sourceCode' in args) ||
            ('manifest' in args && !('sourceCode' in args))) {
            throw new Error(`Invalid add snap args for snap "${snapId}".`);
        }
        const runtime = this._getSnapRuntimeData(snapId);
        if (!runtime.installPromise) {
            console.log(`Adding snap: ${snapId}`);
            runtime.installPromise = this._add(args);
        }
        return runtime.installPromise;
    }
    validateSnapId(snapId) {
        if (!snapId || typeof snapId !== 'string') {
            throw new Error(`Invalid snap id: Not a string. Received "${snapId}"`);
        }
        for (const prefix of Object.values(utils_2.SnapIdPrefixes)) {
            if (snapId.startsWith(prefix) && snapId.replace(prefix, '').length > 0) {
                return;
            }
        }
        throw new Error(`Invalid snap id. Received: "${snapId}"`);
    }
    async _startSnap(snapData) {
        const { snapId } = snapData;
        if (this.isRunning(snapId)) {
            throw new Error(`Snap "${snapId}" is already started.`);
        }
        const result = await this._executeSnap(Object.assign(Object.assign({}, snapData), { endowments: await this._getEndowments(snapId) }));
        this._transitionSnapState(snapId, SnapStatusEvent.start);
        return result;
    }
    /**
     * Gets the names of all endowments that will be added to the Snap's
     * Compartment when it executes. These should be the names of global
     * JavaScript APIs accessible in the root realm of the execution environment.
     *
     * Throws an error if the endowment getter for a permission returns a truthy
     * value that is not an array of strings.
     *
     * @param snapId - The id of the snap whose SES endowments to get.
     * @returns An array of the names of the endowments.
     */
    async _getEndowments(snapId) {
        let allEndowments = [];
        for (const permissionName of this._endowmentPermissionNames) {
            if (this.messagingSystem.call('PermissionController:hasPermission', snapId, permissionName)) {
                const endowments = await this.messagingSystem.call('PermissionController:getEndowments', snapId, permissionName);
                if (endowments) {
                    // We don't have any guarantees about the type of the endowments
                    // value, so we have to guard at runtime.
                    if (!Array.isArray(endowments) ||
                        endowments.some((value) => typeof value !== 'string')) {
                        throw new Error('Expected an array of string endowment names.');
                    }
                    allEndowments = allEndowments.concat(endowments);
                }
            }
        }
        const deduped = [...new Set([...exports.DEFAULT_EXPOSED_APIS, ...allEndowments])];
        if (deduped.length < exports.DEFAULT_EXPOSED_APIS.length + allEndowments.length) {
            console.error('Duplicates found in endowments, default APIs should not be requested.', allEndowments);
        }
        return deduped;
    }
    /**
     * Internal method. See the "add" method.
     *
     * @param snapId - The id of the Snap.
     * @param args - The add snap args.
     * @returns The resulting snap object.
     */
    async _add(args) {
        const { id: snapId, version = utils_2.DEFAULT_REQUESTED_SNAP_VERSION } = args;
        let manifest, sourceCode, svgIcon;
        if ('manifest' in args) {
            manifest = args.manifest;
            sourceCode = args.sourceCode;
            json_schemas_1.validateSnapJsonFile(utils_2.NpmSnapFileNames.Manifest, manifest);
        }
        else {
            ({ manifest, sourceCode, svgIcon } = await this._fetchSnap(snapId, version));
        }
        if (!semver_1.satisfies(manifest.version, version)) {
            throw new Error(`Version mismatch. Manifest for ${snapId} specifies version ${manifest.version} which doesn't satisfy requested version range ${version}`);
        }
        if (typeof sourceCode !== 'string' || sourceCode.length === 0) {
            throw new Error(`Invalid source code for snap "${snapId}".`);
        }
        const initialPermissions = manifest === null || manifest === void 0 ? void 0 : manifest.initialPermissions;
        if (!initialPermissions ||
            typeof initialPermissions !== 'object' ||
            Array.isArray(initialPermissions)) {
            throw new Error(`Invalid initial permissions for snap "${snapId}".`);
        }
        let snap = {
            enabled: true,
            id: snapId,
            initialPermissions,
            manifest,
            permissionName: exports.SNAP_PREFIX + snapId,
            sourceCode,
            status: snapStatusStateMachineConfig.initial,
            version: manifest.version,
        };
        const snapsState = this.state.snaps;
        // restore relevant snap state if it exists
        if (snapsState[snapId]) {
            snap = Object.assign(Object.assign({}, snapsState[snapId]), snap);
        }
        // store the snap back in state
        this.update((state) => {
            state.snaps[snapId] = snap;
        });
        this.messagingSystem.publish(`SnapController:snapAdded`, snapId, snap, svgIcon);
        return snap;
    }
    /**
     * Fetches the manifest and source code of a snap.
     *
     * @param snapId - The id of the Snap.
     * @param version - The version of the Snap to fetch.
     * @returns A tuple of the Snap manifest object and the Snap source code.
     */
    async _fetchSnap(snapId, version) {
        try {
            if (snapId.startsWith(utils_2.SnapIdPrefixes.local)) {
                return this._fetchLocalSnap(snapId.replace(utils_2.SnapIdPrefixes.local, ''));
            }
            else if (snapId.startsWith(utils_2.SnapIdPrefixes.npm)) {
                return this._fetchNpmSnap(snapId.replace(utils_2.SnapIdPrefixes.npm, ''), version);
            }
            // This should be impossible.
            /* istanbul ignore next */
            throw new Error(`Invalid Snap id: "${snapId}"`);
        }
        catch (error) {
            throw new Error(`Failed to fetch Snap "${snapId}": ${error.message}`);
        }
    }
    async _fetchNpmSnap(packageName, version) {
        if (!isValidSnapVersionRange(version)) {
            throw new Error(`Received invalid Snap version range: "${version}".`);
        }
        const { manifest, sourceCode, svgIcon } = await utils_2.fetchNpmSnap(packageName, version, this._npmRegistryUrl);
        return { manifest, sourceCode, svgIcon };
    }
    /**
     * Fetches the manifest and source code of a local snap.
     *
     * @param localhostUrl - The localhost URL to download from.
     * @returns The validated manifest and the source code.
     */
    async _fetchLocalSnap(localhostUrl) {
        // Local snaps are mostly used for development purposes. Fetches were cached in the browser and were not requested
        // afterwards which lead to confusing development where old versions of snaps were installed.
        // Thus we disable caching
        const fetchOptions = { cache: 'no-cache' };
        const manifestUrl = new URL(utils_2.NpmSnapFileNames.Manifest, localhostUrl);
        if (!utils_2.LOCALHOST_HOSTNAMES.has(manifestUrl.hostname)) {
            throw new Error(`Invalid URL: Locally hosted Snaps must be hosted on localhost. Received URL: "${manifestUrl.toString()}"`);
        }
        const _manifest = await (await utils_2.fetchContent(manifestUrl.toString(), fetchOptions)).json();
        json_schemas_1.validateSnapJsonFile(utils_2.NpmSnapFileNames.Manifest, _manifest);
        const manifest = _manifest;
        const { source: { location: { npm: { filePath, iconPath }, }, }, } = manifest;
        const [sourceCode, svgIcon] = await Promise.all([
            (await utils_2.fetchContent(new URL(filePath, localhostUrl).toString(), fetchOptions)).text(),
            iconPath
                ? (await utils_2.fetchContent(new URL(iconPath, localhostUrl).toString(), fetchOptions)).text()
                : undefined,
        ]);
        utils_2.validateSnapShasum(manifest, sourceCode);
        return { manifest, sourceCode, svgIcon };
    }
    /**
     * Initiates a request for the given snap's initial permissions.
     * Must be called in order. See processRequestedSnap.
     *
     * @param snapId - The id of the Snap.
     * @returns The snap's approvedPermissions.
     */
    async authorize(snapId) {
        console.log(`Authorizing snap: ${snapId}`);
        const snapsState = this.state.snaps;
        const snap = snapsState[snapId];
        const { initialPermissions } = snap;
        // Don't prompt if there are no permissions requested:
        if (Object.keys(initialPermissions).length === 0) {
            return [];
        }
        if (initialPermissions === null) {
            return [];
        }
        try {
            const [approvedPermissions] = await this.messagingSystem.call('PermissionController:requestPermissions', { origin: snapId }, initialPermissions);
            return Object.values(approvedPermissions).map((perm) => perm.parentCapability);
        }
        finally {
            const runtime = this._getSnapRuntimeData(snapId);
            runtime.installPromise = null;
        }
    }
    destroy() {
        super.destroy();
        if (this._timeoutForLastRequestStatus) {
            clearTimeout(this._timeoutForLastRequestStatus);
        }
        this.messagingSystem.unsubscribe('ExecutionService:unhandledError', this._onUnhandledSnapError);
        this.messagingSystem.unsubscribe('ExecutionService:unresponsive', this._onUnresponsiveSnap);
    }
    /**
     * Gets the RPC message handler for the given snap.
     *
     * @param snapId - The id of the Snap whose message handler to get.
     */
    async getRpcMessageHandler(snapId) {
        const runtime = this._getSnapRuntimeData(snapId);
        const existingHandler = runtime === null || runtime === void 0 ? void 0 : runtime.rpcHandler;
        if (existingHandler) {
            return existingHandler;
        }
        const rpcHandler = async (origin, request) => {
            let handler = await this._getRpcMessageHandler(snapId);
            if (this.state.snaps[snapId].enabled === false) {
                throw new Error(`Snap "${snapId}" is disabled.`);
            }
            if (this.state.snaps[snapId].status === SnapStatus.installing) {
                throw new Error(`Snap "${snapId}" has not been started yet.`);
            }
            if (!handler && this.isRunning(snapId) === false) {
                // cold start
                await this.startSnap(snapId);
                handler = await this._getRpcMessageHandler(snapId);
            }
            if (!handler) {
                throw new Error(`Snap execution service returned no RPC handler for running snap "${snapId}".`);
            }
            this._recordSnapRpcRequest(snapId);
            // Handle max request time
            let timeout;
            const timeoutPromise = new Promise((_resolve, reject) => {
                timeout = setTimeout(() => {
                    this._stopSnap(snapId);
                    reject(new Error('The request timed out.'));
                }, this._maxRequestTime);
            });
            // This will either get the result or reject due to the timeout.
            const result = await Promise.race([
                handler(origin, request),
                timeoutPromise,
            ]);
            clearTimeout(timeout);
            return result;
        };
        runtime.rpcHandler = rpcHandler;
        return rpcHandler;
    }
    _recordSnapRpcRequest(snapId) {
        const runtime = this._getSnapRuntimeData(snapId);
        runtime.lastRequest = Date.now();
    }
    _getSnapRuntimeData(snapId) {
        if (!this._snapsRuntimeData.has(snapId)) {
            this._snapsRuntimeData.set(snapId, {
                lastRequest: null,
                rpcHandler: null,
                installPromise: null,
            });
        }
        return this._snapsRuntimeData.get(snapId);
    }
}
exports.SnapController = SnapController;
function isValidSnapVersionRange(version) {
    return Boolean(typeof version === 'string' && semver_1.validRange(version) !== null);
}
//# sourceMappingURL=SnapController.js.map