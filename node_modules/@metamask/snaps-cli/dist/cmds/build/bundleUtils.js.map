{"version":3,"file":"bundleUtils.js","sourceRoot":"","sources":["../../../src/cmds/build/bundleUtils.ts"],"names":[],"mappings":";;;;;;AAAA,2BAAuC;AACvC,iFAAwD;AACxD,2CAA8C;AAG9C;;;;;GAKG;AACH,SAAgB,kBAAkB,CAAC,IAAY;IAC7C,MAAM,MAAM,GAAG,sBAAiB,CAAC,IAAI,EAAE;QACrC,SAAS,EAAE,KAAK;QAChB,QAAQ,EAAE,MAAM;KACjB,CAAC,CAAC;IACH,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,GAAG,EAAE,EAAE;QACzB,iBAAU,CAAC,cAAc,EAAE,GAAG,CAAC,OAAO,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;IACrD,CAAC,CAAC,CAAC;IACH,OAAO,MAAM,CAAC;AAChB,CAAC;AATD,gDASC;AAYD;;;;;;;GAOG;AACI,KAAK,UAAU,iBAAiB,CAAC,EACtC,WAAW,EACX,YAAY,EACZ,YAAY,EACZ,GAAG,EACH,IAAI,EACJ,OAAO,EACP,IAAI,GACY;IAChB,IAAI,WAAW,EAAE;QACf,MAAM,iBAAU,CAAC,cAAc,EAAE,WAAW,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;KACpE;IAED,IAAI;QACF,YAAY,CAAC,GAAG,CACd,WAAW,CAAC,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE;YACzD,aAAa,EAAE,IAAI,CAAC,aAAa;SAClC,CAAW,CACb,CAAC;QAEF,IAAI,YAAY,EAAE;YAChB,OAAO,CAAC,GAAG,CAAC,mBAAmB,GAAG,iBAAiB,IAAI,IAAI,CAAC,CAAC;SAC9D;QACD,OAAO,CAAC,IAAI,CAAC,CAAC;KACf;IAAC,OAAO,UAAU,EAAE;QACnB,MAAM,iBAAU,CAAC,cAAc,EAAE,UAAU,CAAC,OAAO,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;KACxE;AACH,CAAC;AA3BD,8CA2BC;AAED;;;;;;;;;;;;GAYG;AACH,SAAgB,WAAW,CACzB,YAA2B,EAC3B,UAA2B,EAAE;IAE7B,IAAI,OAAO,YAAY,KAAK,QAAQ,EAAE;QACpC,OAAO,IAAI,CAAC;KACb;IAED,IAAI,eAAe,GAAG,YAAY,CAAC,IAAI,EAAE,CAAC;IAE1C,IAAI,OAAO,CAAC,aAAa,EAAE;QACzB,eAAe,GAAG,wBAAa,CAAC,eAAe,CAAC,CAAC;KAClD;IAED,wDAAwD;IACxD,eAAe,GAAG,eAAe,CAAC,OAAO,CACvC,2CAA2C,EAC3C,WAAW,CACZ,CAAC;IAEF,4EAA4E;IAC5E,8CAA8C;IAC9C,kCAAkC;IAClC,eAAe,GAAG,eAAe,CAAC,OAAO,CACvC,yBAAyB,EACzB,aAAa,CACd,CAAC;IAEF,2EAA2E;IAC3E,8EAA8E;IAC9E,qCAAqC;IACrC,eAAe,GAAG,eAAe,CAAC,OAAO,CACvC,8BAA8B,EAC9B,eAAe,CAChB,CAAC;IAEF,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE;QAChC,MAAM,IAAI,KAAK,CAAC,6CAA6C,CAAC,CAAC;KAChE;IAED,iDAAiD;IACjD,2BAA2B;IAC3B,IAAI,eAAe,CAAC,OAAO,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC,EAAE;QACxD,eAAe,GAAG,4BAA4B,eAAe,EAAE,CAAC;KACjE;IAED,OAAO,eAAe,CAAC;AACzB,CAAC;AA/CD,kCA+CC","sourcesContent":["import { createWriteStream } from 'fs';\nimport stripComments from '@nodefactory/strip-comments';\nimport { writeError } from '../../utils/misc';\nimport { Option, YargsArgs } from '../../types/yargs';\n\n/**\n * Opens a stream to write the destination file path.\n *\n * @param dest - The output file path\n * @returns - The stream\n */\nexport function createBundleStream(dest: string): NodeJS.WritableStream {\n  const stream = createWriteStream(dest, {\n    autoClose: false,\n    encoding: 'utf8',\n  });\n  stream.on('error', (err) => {\n    writeError('Write error:', err.message, err, dest);\n  });\n  return stream;\n}\n\ntype CloseStreamArgs = {\n  bundleError: Error;\n  bundleBuffer: Buffer;\n  bundleStream: NodeJS.WritableStream;\n  src: string;\n  dest: string;\n  resolve: (value: boolean) => void;\n  argv: YargsArgs;\n};\n\n/**\n * Postprocesses the bundle string and closes the write stream.\n *\n * @param stream - The write stream\n * @param bundleString - The bundle string\n * @param options - post process options\n * @param options.stripComments\n */\nexport async function closeBundleStream({\n  bundleError,\n  bundleBuffer,\n  bundleStream,\n  src,\n  dest,\n  resolve,\n  argv,\n}: CloseStreamArgs) {\n  if (bundleError) {\n    await writeError('Build error:', bundleError.message, bundleError);\n  }\n\n  try {\n    bundleStream.end(\n      postProcess(bundleBuffer ? bundleBuffer.toString() : null, {\n        stripComments: argv.stripComments,\n      }) as string,\n    );\n\n    if (bundleBuffer) {\n      console.log(`Build success: '${src}' bundled as '${dest}'!`);\n    }\n    resolve(true);\n  } catch (closeError) {\n    await writeError('Write error:', closeError.message, closeError, dest);\n  }\n}\n\n/**\n * Postprocesses a JavaScript bundle string such that it can be evaluated in SES.\n * Currently:\n * - converts certain dot notation to string notation (for indexing)\n * - makes all direct calls to eval indirect\n * - wraps original bundle in anonymous function\n * - handles certain Babel-related edge cases\n *\n * @param bundleString - The bundle string\n * @param options - post process options\n * @param options.stripComments\n * @returns - The postprocessed bundle string\n */\nexport function postProcess(\n  bundleString: string | null,\n  options: Partial<Option> = {},\n): string | null {\n  if (typeof bundleString !== 'string') {\n    return null;\n  }\n\n  let processedString = bundleString.trim();\n\n  if (options.stripComments) {\n    processedString = stripComments(processedString);\n  }\n\n  // stuff.eval(otherStuff) => (1, stuff.eval)(otherStuff)\n  processedString = processedString.replace(\n    /((?:\\b[\\w\\d]*[\\])]?\\.)+eval)(\\([^)]*\\))/gu,\n    '(1, $1)$2',\n  );\n\n  // if we don't do the above, the below causes syntax errors if it encounters\n  // things of the form: \"something.eval(stuff)\"\n  // eval(stuff) => (1, eval)(stuff)\n  processedString = processedString.replace(\n    /(\\b)(eval)(\\([^)]*\\))/gu,\n    '$1(1, $2)$3',\n  );\n\n  // Browserify provides the Buffer global as an argument to modules that use\n  // it, but this does not work in SES. Since we pass in Buffer as an endowment,\n  // we can simply remove the argument.\n  processedString = processedString.replace(\n    /^\\(function \\(Buffer\\)\\{$/gmu,\n    '(function (){',\n  );\n\n  if (processedString.length === 0) {\n    throw new Error(`Bundled code is empty after postprocessing.`);\n  }\n\n  // handle some cases by declaring missing globals\n  // Babel regeneratorRuntime\n  if (processedString.indexOf('regeneratorRuntime') !== -1) {\n    processedString = `var regeneratorRuntime;\\n${processedString}`;\n  }\n\n  return processedString;\n}\n"]}