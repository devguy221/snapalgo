"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processInvalidTranspilation = exports.sanitizeDependencyPaths = exports.getDependencyRegExp = exports.processDependencies = exports.postProcess = exports.writeBundleFile = void 0;
const fs_1 = require("fs");
const strip_comments_1 = __importDefault(require("@nodefactory/strip-comments"));
const misc_1 = require("../../utils/misc");
const builders_1 = require("../../builders");
/**
 * Performs postprocessing on the bundle contents and writes them to disk.
 * Intended to be used in the callback passed to the Browserify `.bundle()`
 * call.
 *
 * @param options - Options bag.
 * @param options.bundleError - Any error received from Browserify.
 * @param options.bundleBuffer - The {@link Buffer} with the bundle contents
 * from Browserify.
 * @param options.src - The source file path.
 * @param options.dest - The destination file path.
 * @param options.resolve - A {@link Promise} resolution function, so that we
 * can use promises and `async`/`await` even though Browserify uses callbacks.
 * @param options.argv - The Yargs `argv` object.
 */
async function writeBundleFile({ bundleError, bundleBuffer, src, dest, resolve, argv, }) {
    if (bundleError) {
        await misc_1.writeError('Build error:', bundleError.message, bundleError);
    }
    try {
        await fs_1.promises.writeFile(dest, postProcess(bundleBuffer ? bundleBuffer.toString() : null, {
            stripComments: argv.stripComments,
            transformHtmlComments: argv.transformHtmlComments,
        }));
        if (bundleBuffer) {
            console.log(`Build success: '${src}' bundled as '${dest}'!`);
        }
        resolve(true);
    }
    catch (error) {
        await misc_1.writeError('Write error:', error.message, error, dest);
    }
}
exports.writeBundleFile = writeBundleFile;
/**
 * Postprocesses a JavaScript bundle string such that it can be evaluated in SES.
 * Currently:
 * - converts certain dot notation to string notation (for indexing)
 * - makes all direct calls to eval indirect
 * - wraps original bundle in anonymous function
 * - handles certain Babel-related edge cases
 *
 * @param bundleString - The bundle string
 * @param options - post process options
 * @param options.stripComments
 * @returns - The postprocessed bundle string
 */
function postProcess(bundleString, options = {}) {
    if (typeof bundleString !== 'string') {
        return null;
    }
    let processedString = bundleString.trim();
    if (options.stripComments) {
        // TODO: Upstream a better fix to @nodefactory/strip-comments
        // The strip-comments package has issues with block comments of the
        // form "/**/", and so we remove them manually first:
        processedString = processedString.replace(/\/\*\*\//gu, '');
        processedString = strip_comments_1.default(processedString);
    }
    // Break up tokens that could be parsed as HTML comment terminators.
    // The regular expressions below are written strangely so as to avoid the
    // appearance of such tokens in our source code.
    // Ref: https://github.com/endojs/endo/blob/70cc86eb400655e922413b99c38818d7b2e79da0/packages/ses/error-codes/SES_HTML_COMMENT_REJECTED.md
    // This aggressive hack may change the behavior of programs that contain HTML
    // comment terminators in string literals.
    if (options.transformHtmlComments) {
        processedString = processedString.replace(new RegExp(`<!${'--'}`, 'gu'), '< !--');
        processedString = processedString.replace(new RegExp(`${'--'}>`, 'gu'), '-- >');
    }
    // stuff.eval(otherStuff) => (1, stuff.eval)(otherStuff)
    processedString = processedString.replace(/((?:\b[\w\d]*[\])]?\.)+eval)(\([^)]*\))/gu, '(1, $1)$2');
    // If we don't do the above, the below causes syntax errors if it encounters
    // things of the form: "something.eval(stuff)"
    // eval(stuff) => (1, eval)(stuff)
    processedString = processedString.replace(/(\b)(eval)(\([^)]*\))/gu, '$1(1, $2)$3');
    // Browserify provides the Buffer global as an argument to modules that use
    // it, but this does not work in SES. Since we pass in Buffer as an endowment,
    // we can simply remove the argument.
    processedString = processedString.replace(/^\(function \(Buffer\)\{$/gmu, '(function (){');
    if (processedString.length === 0) {
        throw new Error(`Bundled code is empty after postprocessing.`);
    }
    // handle some cases by declaring missing globals
    // Babel regeneratorRuntime
    if (processedString.indexOf('regeneratorRuntime') !== -1) {
        processedString = `var regeneratorRuntime;\n${processedString}`;
    }
    return processedString;
}
exports.postProcess = postProcess;
/**
 * Processes dependencies and updates argv with an options object
 * @param argv
 */
function processDependencies(argv) {
    const { depsToTranspile, transpilationMode } = argv;
    const babelifyOptions = {};
    if (transpilationMode === builders_1.TranspilationModes.localAndDeps) {
        const regexpStr = getDependencyRegExp(depsToTranspile);
        if (regexpStr !== null) {
            babelifyOptions.ignore = [regexpStr];
        }
    }
    return babelifyOptions;
}
exports.processDependencies = processDependencies;
/**
 * Processes a string of space delimited dependencies into one regex string
 * @param dependencies
 * @returns a regexp string
 */
function getDependencyRegExp(dependencies) {
    let regexp = null;
    if (!dependencies || dependencies.includes('.') || !dependencies.length) {
        return regexp;
    }
    const paths = sanitizeDependencyPaths(dependencies);
    regexp = `/node_modules/(?!${paths.shift()}`;
    paths.forEach((path) => (regexp += `|${path}`));
    regexp += '/)';
    return RegExp(regexp, 'u');
}
exports.getDependencyRegExp = getDependencyRegExp;
/**
 * Helper function remove any leading and trailing slashes from dependency list
 * @param dependencies
 * @returns an array of sanitized paths
 */
function sanitizeDependencyPaths(dependencies) {
    return dependencies.map((dependency) => {
        return dependency.replace(/^[/\\]+/u, '').replace(/[/\\]+$/u, '');
    });
}
exports.sanitizeDependencyPaths = sanitizeDependencyPaths;
function processInvalidTranspilation(argv) {
    if (argv.depsToTranspile &&
        argv.transpilationMode !== builders_1.TranspilationModes.localAndDeps) {
        throw new Error('"depsToTranspile" can only be specified if "transpilationMode" is set to "localAndDeps" .');
    }
}
exports.processInvalidTranspilation = processInvalidTranspilation;
//# sourceMappingURL=utils.js.map