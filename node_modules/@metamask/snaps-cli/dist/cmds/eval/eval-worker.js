"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const worker_threads_1 = require("worker_threads");
const fs_1 = require("fs");
const crypto_1 = __importDefault(require("crypto"));
// eslint-disable-next-line import/no-unassigned-import
require("ses/lockdown");
lockdown({
    consoleTaming: 'unsafe',
    errorTaming: 'unsafe',
    mathTaming: 'unsafe',
    dateTaming: 'unsafe',
    overrideTaming: 'severe',
});
if (worker_threads_1.parentPort !== null) {
    worker_threads_1.parentPort.on('message', (message) => {
        const { snapFilePath } = message;
        new Compartment(getMockEndowments()).evaluate(fs_1.readFileSync(snapFilePath, 'utf8'));
        setTimeout(() => process.exit(0), 1000); // Hack to ensure worker exits
    });
}
function getMockSnapProvider() {
    const mockProvider = new events_1.EventEmitter();
    mockProvider.registerRpcMessageHandler = () => true;
    mockProvider.request = async () => true;
    return mockProvider;
}
function getMockEndowments() {
    const endowments = {
        BigInt,
        Buffer,
        console,
        crypto: crypto_1.default,
        Date,
        fetch: () => true,
        Math,
        wallet: getMockSnapProvider(),
        setTimeout,
        SubtleCrypto: () => undefined,
        WebSocket: () => true,
        XMLHttpRequest: () => true,
    };
    return Object.assign(Object.assign({}, endowments), { window: endowments });
}
//# sourceMappingURL=eval-worker.js.map