"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyConfig = void 0;
const fs_1 = require("fs");
const yargs_parser_1 = __importDefault(require("yargs-parser"));
const builders_1 = __importDefault(require("../builders"));
const misc_1 = require("./misc");
const _1 = require(".");
// Note that the below function is necessary because yarg's .config() function
// leaves much to be desired.
//
// In particular, it will set all properties included in the config file
// regardless of the command, which fails during validation.
/**
 * Attempts to read configuration options for package.json and the config file,
 * and apply them to argv if they weren't already set.
 *
 * Arguments are only set per the snap-cli config file if they were not specified
 * on the command line.
 */
function applyConfig(processArgv, yargsArgv, yargsInstance) {
    // Instances of yargs has a number of undocumented functions, including
    // getOptions. This function returns an object with properties "key" and
    // "alias", which specify the options associated with the current command and
    // their aliases, respectively.
    //
    // We leverage this to ensure that the config is only applied to args that are
    // valid for the current command, and that weren't specified by the user on
    // the command line.
    //
    // If we set args that aren't valid for the current command, yargs will error
    // during validation.
    const { alias: aliases, key: options } = yargsInstance.getOptions();
    const parsedProcessArgv = yargs_parser_1.default(processArgv, {
        alias: aliases,
    });
    delete parsedProcessArgv._; // irrelevant yargs parser artifact
    const commandOptions = new Set(Object.keys(options));
    const shouldSetArg = (key) => {
        return (commandOptions.has(key) &&
            !Object.prototype.hasOwnProperty.call(parsedProcessArgv, key));
    };
    // Now, we attempt to read and apply config from the config file, if any.
    let cfg = {};
    try {
        cfg = JSON.parse(fs_1.readFileSync(_1.CONFIG_FILE, 'utf8'));
    }
    catch (err) {
        if (err.code === 'ENOENT') {
            // If there's no config file, we're done here.
            return;
        }
        misc_1.logError(`Error: "${_1.CONFIG_FILE}" exists but could not be parsed. Ensure your config file is valid JSON and try again.`, err);
        process.exit(1);
    }
    if (cfg && typeof cfg === 'object' && !Array.isArray(cfg)) {
        for (const key of Object.keys(cfg)) {
            if (Object.hasOwnProperty.call(builders_1.default, key)) {
                if (shouldSetArg(key)) {
                    yargsArgv[key] = cfg[key];
                }
            }
            else {
                misc_1.logError(`Error: Encountered unrecognized config property "${key}" in config file "${_1.CONFIG_FILE}". Remove the property and try again.`);
                process.exit(1);
            }
        }
    }
    else {
        const cfgType = cfg === null ? 'null' : typeof cfg;
        misc_1.logError(`Error: The config file must consist of a top-level JSON object. Received "${cfgType}" from "${_1.CONFIG_FILE}". Fix your config file and try again.`);
        process.exit(1);
    }
}
exports.applyConfig = applyConfig;
//# sourceMappingURL=snap-config.js.map