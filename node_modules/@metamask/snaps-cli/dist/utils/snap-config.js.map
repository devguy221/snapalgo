{"version":3,"file":"snap-config.js","sourceRoot":"","sources":["../../src/utils/snap-config.ts"],"names":[],"mappings":";;;;;;AAAA,2BAAkC;AAElC,gEAAsC;AAEtC,2DAAmC;AACnC,iCAAkC;AAClC,wBAAgC;AAEhC,8EAA8E;AAC9E,6BAA6B;AAC7B,EAAE;AACF,wEAAwE;AACxE,4DAA4D;AAE5D;;;;;;GAMG;AACH,SAAgB,WAAW,CACzB,WAAqB,EACrB,SAAoB,EACpB,aAA2B;IAE3B,uEAAuE;IACvE,wEAAwE;IACxE,6EAA6E;IAC7E,+BAA+B;IAC/B,EAAE;IACF,8EAA8E;IAC9E,2EAA2E;IAC3E,oBAAoB;IACpB,EAAE;IACF,6EAA6E;IAC7E,qBAAqB;IACrB,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,GAAG,EAAE,OAAO,EAAE,GACpC,aACD,CAAC,UAAU,EAGX,CAAC;IAEF,MAAM,iBAAiB,GAAG,sBAAU,CAAC,WAAW,EAAE;QAChD,KAAK,EAAE,OAAO;KACf,CAA4B,CAAC;IAC9B,OAAO,iBAAiB,CAAC,CAAC,CAAC,CAAC,mCAAmC;IAE/D,MAAM,cAAc,GAAG,IAAI,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;IAErD,MAAM,YAAY,GAAG,CAAC,GAAW,EAAW,EAAE;QAC5C,OAAO,CACL,cAAc,CAAC,GAAG,CAAC,GAAG,CAAC;YACvB,CAAC,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,iBAAiB,EAAE,GAAG,CAAC,CAC9D,CAAC;IACJ,CAAC,CAAC;IAEF,yEAAyE;IACzE,IAAI,GAAG,GAA4B,EAAE,CAAC;IACtC,IAAI;QACF,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,iBAAY,CAAC,cAAW,EAAE,MAAM,CAAC,CAAC,CAAC;KACrD;IAAC,OAAO,GAAG,EAAE;QACZ,IAAI,GAAG,CAAC,IAAI,KAAK,QAAQ,EAAE;YACzB,8CAA8C;YAC9C,OAAO;SACR;QAED,eAAQ,CACN,WAAW,cAAW,wFAAwF,EAC9G,GAAG,CACJ,CAAC;QACF,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;KACjB;IAED,IAAI,GAAG,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;QACzD,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;YAClC,IAAI,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,kBAAQ,EAAE,GAAG,CAAC,EAAE;gBAC7C,IAAI,YAAY,CAAC,GAAG,CAAC,EAAE;oBACrB,SAAS,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;iBAC3B;aACF;iBAAM;gBACL,eAAQ,CACN,oDAAoD,GAAG,qBAAqB,cAAW,uCAAuC,CAC/H,CAAC;gBACF,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;aACjB;SACF;KACF;SAAM;QACL,MAAM,OAAO,GAAG,GAAG,KAAK,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,GAAG,CAAC;QAEnD,eAAQ,CACN,6EAA6E,OAAO,WAAW,cAAW,wCAAwC,CACnJ,CAAC;QACF,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;KACjB;AACH,CAAC;AA3ED,kCA2EC","sourcesContent":["import { readFileSync } from 'fs';\nimport { Arguments } from 'yargs';\nimport yargsParse from 'yargs-parser';\nimport yargs from 'yargs/yargs';\nimport builders from '../builders';\nimport { logError } from './misc';\nimport { CONFIG_FILE } from '.';\n\n// Note that the below function is necessary because yarg's .config() function\n// leaves much to be desired.\n//\n// In particular, it will set all properties included in the config file\n// regardless of the command, which fails during validation.\n\n/**\n * Attempts to read configuration options for package.json and the config file,\n * and apply them to argv if they weren't already set.\n *\n * Arguments are only set per the snap-cli config file if they were not specified\n * on the command line.\n */\nexport function applyConfig(\n  processArgv: string[],\n  yargsArgv: Arguments,\n  yargsInstance: typeof yargs,\n): void {\n  // Instances of yargs has a number of undocumented functions, including\n  // getOptions. This function returns an object with properties \"key\" and\n  // \"alias\", which specify the options associated with the current command and\n  // their aliases, respectively.\n  //\n  // We leverage this to ensure that the config is only applied to args that are\n  // valid for the current command, and that weren't specified by the user on\n  // the command line.\n  //\n  // If we set args that aren't valid for the current command, yargs will error\n  // during validation.\n  const { alias: aliases, key: options } = (\n    yargsInstance as any\n  ).getOptions() as {\n    alias: Record<string, string[]>;\n    key: Record<string, unknown>;\n  };\n\n  const parsedProcessArgv = yargsParse(processArgv, {\n    alias: aliases,\n  }) as Record<string, unknown>;\n  delete parsedProcessArgv._; // irrelevant yargs parser artifact\n\n  const commandOptions = new Set(Object.keys(options));\n\n  const shouldSetArg = (key: string): boolean => {\n    return (\n      commandOptions.has(key) &&\n      !Object.prototype.hasOwnProperty.call(parsedProcessArgv, key)\n    );\n  };\n\n  // Now, we attempt to read and apply config from the config file, if any.\n  let cfg: Record<string, unknown> = {};\n  try {\n    cfg = JSON.parse(readFileSync(CONFIG_FILE, 'utf8'));\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      // If there's no config file, we're done here.\n      return;\n    }\n\n    logError(\n      `Error: \"${CONFIG_FILE}\" exists but could not be parsed. Ensure your config file is valid JSON and try again.`,\n      err,\n    );\n    process.exit(1);\n  }\n\n  if (cfg && typeof cfg === 'object' && !Array.isArray(cfg)) {\n    for (const key of Object.keys(cfg)) {\n      if (Object.hasOwnProperty.call(builders, key)) {\n        if (shouldSetArg(key)) {\n          yargsArgv[key] = cfg[key];\n        }\n      } else {\n        logError(\n          `Error: Encountered unrecognized config property \"${key}\" in config file \"${CONFIG_FILE}\". Remove the property and try again.`,\n        );\n        process.exit(1);\n      }\n    }\n  } else {\n    const cfgType = cfg === null ? 'null' : typeof cfg;\n\n    logError(\n      `Error: The config file must consist of a top-level JSON object. Received \"${cfgType}\" from \"${CONFIG_FILE}\". Fix your config file and try again.`,\n    );\n    process.exit(1);\n  }\n}\n"]}